##小白读源码系列(一) - YYModel
* OC代码

![](/Users/liuzhigao/Desktop/自定义转场动画/Result.png)

####目录结构
* 不浪费大家时间，就废话少说了。

![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170612_2.png)

* 从目录结构初步估计
  * `NSObject+YYModel：`模型
  * `YYClassInfo：`主要功能
  * `YYModel：`要导入的类
* 目录确实简洁，对比`MJExtension`和`JSONModel`真的是没有对比就没有伤害😅。
* 作为一个小白，需要尽可能的吸收全部的养分，<mark>所以这种框架的目录结构，还是值得注意的，非常简单明了的概括了第三方框架的基本布局，可以学习。</mark>

![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170612_3.png)
![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170612_4.png)

####YYModel.h文件
![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170612_7.png)

* <mark>包含以下注意点</mark>：

>* `__has_include`
>  * 此宏传入一个你想引入文件的名称作为参数，如果该文件能够被引入则返回 1，否则返回 0。
>* `FOUNDATION_EXPORT`
>  * 头文件大家自己研究，小编功力有限😅。
>  * **`FOUNDATION_EXPORT` 和`#define` 作用是一样的：**
>  * 使用第一种在检索字符串的时候用 `==` ，第二种在检索字符串的时候使用`isEqualToString`，在效率上前者由于是基于地址的判断，速度会更快一些。
>  * 第一种是直接比较指针地址，第二种则是一一比较字符串的每一个字符是否相等.

####YYClassInfo.h文件
* 开篇会注意到有`NS_ASSUME_NONNULL_BEGIN`这个宏。
  * `NS_ASSUME_NONNULL_BEGIN`和`NS_ASSUME_NONNULL_END`配对使用
  * 它们之间的所有属性默认都是`nonnull`
  * `nonnull` : `setter` 和 `getter` 都不能为`nil`
  * 写法一：`@property (nonatomic, strong, nonnull) NSArray *names;`
  * 写法二：`@property (nonatomic, strong) NSArray * __nonnull names;`
  * 当然，是在该属性没有其他要求的前提下。
* 之后一堆类型定义，暂且不看。
![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170612_8.png)

* 再往下看

>* `YYEncodingType YYEncodingGetType(const char *typeEncoding);`
>  * C语言函数，返回值为`YYEncodingType`，接收参数为不可变的字符数组`typeEncoding`
>  * 字符串就是字符数组
>* 内部实现
>* <mark>`char`：字符数组</mark>
>
>```swift
>YYEncodingType YYEncodingGetType(const char *typeEncoding) {
>     //用一个可变字符数组type保存传过来的不可变字符数组typeEncoding
    //如果type不存在就返回unknown类型
    char *type = (char *)typeEncoding;
    if (!type) return YYEncodingTypeUnknown;
    //获取字符数组的长度
    //如果长度为0返回unknown
    size_t len = strlen(type);
    if (len == 0) return YYEncodingTypeUnknown;
    
>     //声明一个encoding类型
    YYEncodingType qualifier = 0;
    //设置一个值为true的bool用于while死循环
    bool prefix = true;
    while (prefix) {
        switch (*type) {//从字符数组type的首地址开始一个一个取出内部的字符
            case 'r': {
                //对qualifier进行或运算
                qualifier |= YYEncodingTypeQualifierConst;
                //随后地址指针+1
                type++;
            } break;
            case 'n': {
                qualifier |= YYEncodingTypeQualifierIn;
                type++;
            } break;
            case 'N': {
                qualifier |= YYEncodingTypeQualifierInout;
                type++;
            } break;
            case 'o': {
                qualifier |= YYEncodingTypeQualifierOut;
                type++;
            } break;
            case 'O': {
                qualifier |= YYEncodingTypeQualifierBycopy;
                type++;
            } break;
            case 'R': {
                qualifier |= YYEncodingTypeQualifierByref;
                type++;
            } break;
            case 'V': {
                qualifier |= YYEncodingTypeQualifierOneway;
                type++;
            } break;
            default: { prefix = false; } break;
        }
    }

>     len = strlen(type);
    if (len == 0) return YYEncodingTypeUnknown | qualifier;

>     switch (*type) {
        case 'v': return YYEncodingTypeVoid | qualifier;
        case 'B': return YYEncodingTypeBool | qualifier;
        case 'c': return YYEncodingTypeInt8 | qualifier;
        case 'C': return YYEncodingTypeUInt8 | qualifier;
        case 's': return YYEncodingTypeInt16 | qualifier;
        case 'S': return YYEncodingTypeUInt16 | qualifier;
        case 'i': return YYEncodingTypeInt32 | qualifier;
        case 'I': return YYEncodingTypeUInt32 | qualifier;
        case 'l': return YYEncodingTypeInt32 | qualifier;
        case 'L': return YYEncodingTypeUInt32 | qualifier;
        case 'q': return YYEncodingTypeInt64 | qualifier;
        case 'Q': return YYEncodingTypeUInt64 | qualifier;
        case 'f': return YYEncodingTypeFloat | qualifier;
        case 'd': return YYEncodingTypeDouble | qualifier;
        case 'D': return YYEncodingTypeLongDouble | qualifier;
        case '#': return YYEncodingTypeClass | qualifier;
        case ':': return YYEncodingTypeSEL | qualifier;
        case '*': return YYEncodingTypeCString | qualifier;
        case '^': return YYEncodingTypePointer | qualifier;
        case '[': return YYEncodingTypeCArray | qualifier;
        case '(': return YYEncodingTypeUnion | qualifier;
        case '{': return YYEncodingTypeStruct | qualifier;
        case '@': {
            if (len == 2 && *(type + 1) == '?')
                return YYEncodingTypeBlock | qualifier;
            else
                return YYEncodingTypeObject | qualifier;
        }
        default: return YYEncodingTypeUnknown | qualifier;
    }
}
>```
>####小插曲[Type Encodings](http://nshipster.cn/type-encodings/)
>* 精简版--见大胡子相关笔记
>

##小白读源码系列(二) - FDTemplateLayoutCell
* OC 代码

![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170627_1.png)
####FDFeedViewController.h
* 开头一个枚举定义，这里复习一下写法

>* OC
>
>```swift
//枚举定义方法一：
typedef enum : NSUInteger {
    Yhhhhjj = 0
} Yhhhh;

>//枚举定义方法二：
typedef NS_ENUM(NSUInteger, Yhhhh){
    Yhhhhjj = 0
};
```
>
>* swift
>
>```swift
>//--------------------------没有定义枚举值类型------------------------
//基本格式:
enum Method{
    case 枚举值
}
//连写格式：
enum Method{
//    case Add
//    case Sub
//    case Mul
//    case Div
    // 可以连在一起写
    case Add, Sub, Mul, Div
}
// 使用 1
var m: Method = .Add
// 使用 2
var m1 = Method.Add
// 使用 3
// 注意: 如果case中包含了枚举所有的值, 可以不写default.否则必须写default
switch (Method.Add){
    case Method.Add:
        print("加法")
    case Method.Sub:
        print("减法")
    case Method.Mul:
        print("除法")
    case Method.Div:
        print("乘法")
//    default:
//        print("都不是")
}
//------------------------定义枚举值类型------------------------------
>/*
原始值:
 OC中枚举的本质就是整数,所以OC中的枚举是有原始值的,默认是从0开始
而Swift中的枚举默认是没有原始值的, 但是可以在定义时告诉系统让枚举有原始值
*/

>//基本格式:
enum Method: 枚举值原始值类型{
    case 枚举值
}
//连写格式：
enum Method2: Int{
    // 可以连在一起写
    case Add, Sub, Mul, Div
}
// 和OC中的枚举一样, 也可以指定原始值, 后面的值默认+1
enum Method3: Int{
    case Add = 5, Sub, Mul, Div
}
//----------------通过枚举取原始值
>// 如果指定其它类型，如：`Double`, 必须给所有枚举值赋值, 不能自动递增了
enum Method4: Double {
    // 可以连在一起写
    case Add = 5.0, Sub = 6.0, Mul = 6.1, Div = 8.0
}
// 使用
print(Method4.Sub.rawValue)
//----------------通过原始值取枚举
>
enum Method5: String {
    case Add = "add", Sub = "sub", Mul = "mul", Div = "div"
}
>// 使用
let m2 = Method5(rawValue: "add")
print(m2)
//----------------枚举相关值
>/*
枚举相关值:
可以让枚举值对应的原始值不是唯一的, 而是一个变量.
每一个枚举可以是在某种模式下的一些特定值
*/
enum line{
    case Start(start:Double, end:Double)
    case Start(start: Double, length:Double)
}
// 使用
>var lsd = line.Start(start: 0.0, length: 100.0)
lsd = line.Start(start: 0.0, end: 50.0)
>```
