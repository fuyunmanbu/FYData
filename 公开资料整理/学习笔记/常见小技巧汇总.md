##常见小技巧汇总
###目录

>### `NSString`
>* 7. **字符串反转**
>* 11. **字符串按多个符号分割**
>* 13. **iOS 获取汉字的拼音**
>* 24. **阿拉伯数字转中文格式**
>* 25. **`Base64` 编码与 `NSString` 对象或 `NSData` 对象的转换**
>* 29. **图片上绘制文字**
>* 34. **计算字符串字符长度，一个汉字算两个字符**
>* 38. **字符串中是否含有中文**
>* 46. **`iOS`中数字的格式化**
>* 55. **`NSString` 进行 `URL` 编码和解码**
>* 67. **判断输入的是否是有效数字**
>* 74. **`NSString` 过滤特殊字符**
>* 85. **字符串除去空格需求，转变字母大小写**
>* 90. **`UIImage`与字符串互转**
>* 91. **`NSDate`与`NSString`的相互转化**

* **
>### `UIColor`
>* 6. **获取图片某一点的颜色**
>* 58. **获取 `UIColor` 的 `RGBA` 值**
>* 68. **十六进制颜色转换成 `UIColor`**

* **
>### `UIImage`
>* 6. **获取图片某一点的颜色**
>* 16. **获取实际使用的 `LaunchImage` 图片**
>* 27. **`UIImage` 占用内存大小**
>* 29. **图片上绘制文字**
>* 47. **如何获取 `WebView` 所有的图片地址**
>* 71. **一些控件没有 `setBackgroundImage` 方法的可以用这个设置背景图片**
>* 83. **`UIImageView`填充模式**
>* 86. **屏幕截图**
>* 88. **图片拉伸**
>* 90. **`UIImage`与字符串互转**
>* 94. **递归缩放包含矢量内容的视图，防止模糊和锯齿**

* **
>###`UIWebView`
>* 47. **如何获取 `WebView` 所有的图片地址**
>* 48. **获取到 `webview` 的高度**
>* 56. **`UIWebView` 设置 `User-Agent`**
>* 61. **`UIWebView `里面的图片自适应屏幕**
>* 76. **`iOS`项目里加载本地 `HTML`**
>* 92.`UIWebView`退出时，使音频停止播放

* **
> ###`NSArray`
>* 19. **`NSArray` 快速求总和 最大值 最小值 和 平均值**

* **
>###`UILable`
>* 80. **设置`Label`中不同文字的颜色**
>* 82. **调整`Label`行间距**

* **
> ###`UITextField`
>* 20. **修改 `UITextField` 中 `Placeholder` 的文字颜色**
>* 39. **`UITextField` 每四位加一个空格代理方法**
>* 59. **修改 `textField` 的 `placeholder` 的字体颜色、大小**
>* 69. **`UITextField` 截断字符串。**

* **
>###`NSDate`
>* 21. **关于 `NSDateFormatter` 的格式**
>* 42. **判断两个日期是否在同一周(写在 `NSDate` 的 `category` 里面)**
>* 65. **时间戳转换成指定格式的日期**
>* 66. **日期转换成时间戳**
>* 91. **`NSDate`与`NSString`的相互转化**

* **
>###`NSData`
>* 25. **`Base64` 编码与 `NSString` 对象或 `NSData` 对象的转换**

* **
>### `UITableView`
>* 1. **`UITableView` 的 `Group` 样式下顶部空白处理**
>* 2. **`UITableView` 的 `plain`样式下，取消区头停滞效果**
>* 78. **使 `tableViewCell`分割线的两头都接触边缘**
>* 93. **头部视图放大**

* **
>###`UICollectionView`
>* 26. **取消 `UICollectionView` 的隐式动画**

* **
>###`UIScrollerView`
>* 36. **防止 `scrollView` 手势覆盖侧滑手势**

* **
>### `UIView`
>* 3. **获取某个 `view` 所在的控制器**
>* 9. **模态推出一个透明界面**
>* 18. **判断 `view` 是不是指定视图的子视图**
>* 30. **查找一个视图的所有子视图**
>* 32. **`UIView` 设置部分圆角**
>* 35. **给 `UIView` 设置图片**
>* 49. **利用 `LLDB` 打印 `View` 所有子视图**
>* 73. **删除所有子控件**

* **
>### `控制器`
>* 3. **获取某个 `view` 所在的控制器**
>* 9. **模态推出一个透明界面**
>* 15. **判断当前 `ViewController` 是 `push` 还是 `present` 的方式显示的**

* **
>###声音相关
>* 72. **设置震动和声音**
>* 81. **播放声音**

* **
>### `数据持久化`
>* 4. **两种方法删除 `NSUserDefaults` 所有记录**
>* 31. **计算文件/文件夹大小**
>* 53. **`iOS` 开发中一些相关的路径**
>* 57. **获取硬盘总容量与可用容量**

* **
>###导航栏/tabBar
>* 37. **去掉导航栏返回的 `back` 标题,只剩下箭头**
>* 50. **`navigationBar` 变为纯透明**
>* 51. **`tabBar` 变为纯透明**
>* 52. **`navigationBar` 根据滑动距离的渐变色实现**
>* 54. **`navigationItem` 的 `BarButtonItem` 如何紧靠屏幕右边界或者左边界？**
>* 87. **动态设置导航条`hidden`**
>* 89. **去掉导航栏/tabBar上的黑线**
>* 96. **设置导航栏背景颜色**

* **
>###正则表达式
>* 38. **字符串中是否含有中文**
>* 62. **手机号码匹配**
>* 63. **邮箱匹配**
>* 67. **判断输入的是否是有效数字**

* **
>###定时器
>* 28. **`GCD timer` 定时器**

* **
>###事件处理
>* 36. **防止 `scrollView` 手势覆盖侧滑手势**
>* 44. **屏蔽触发事件，2 秒后取消屏蔽(没有透明阴影效果，一片白)**
>* 95. **判断某个点是否在『视图区域』内,避免`Rotation`形变手势带来的`frame`差错**

* **
>###runtime
>* 40. **获取私有属性和成员变量 `#import <objc/runtime.h>`**

* **
>###第三方框架相关
>* 60. **`AFN `移除 `JSON` 中的 `NSNull`**

* **
>### `系统相关／application`
>* 8. **禁止锁屏**
>* 5. **打印系统所有已注册的字体名称**
>* 14. **手动更改 iOS 状态栏的颜色**
>* 43. **打开系统设置界面、打电话、打开网址、发邮件、发短信等**
>* 44. **屏蔽触发事件，2 秒后取消屏蔽(没有透明阴影效果，一片白)**
>* 77. **`layoutSubviews`调用的调用时机**
>* 79. **让`iOS`应用直接退出**
>* 84. **设置状态栏文字的样式/颜色**

* **
>### `Other`
>* 10. **显示／隐藏文件**
>* 12. **iOS跳转到 `App Store` 下载应用评分**
>* 13. **iOS 获取汉字的拼音**
>* 16. **获取实际使用的 `LaunchImage` 图片**
>* 17. **判断对象是否遵循了某协议**
>* 22. **获取一个类的所有子类**
>* 24. **阿拉伯数字转中文格式**
>* 31. **计算文件/文件夹大小**
>* 33. **取上整与取下整**
>* 41. **获取手机安装的应用信息**
>* 43. **打开系统设置界面、打电话、打开网址、发邮件、发短信等**
>* 45. **`fillRule` 原理**
>* 46. **`iOS`中数字的格式化**
>* 53. **`iOS` 开发中一些相关的路径**
>* 57. **获取硬盘总容量与可用容量**
>* 60. **`AFN `移除 `JSON` 中的 `NSNull`**
>* 64. **`base64` 加密**
>* 67. **判断输入的是否是有效数字**
>* 70. **打开手机 `QQ` 与指定人聊天。**
>* 73. **删除所有子控件**
>* 75. **`app`提交审核上架关于 `IDFA` 广告标识符——`IDFA(identifier for advertising)`**
>* 77. **`layoutSubviews`调用的调用时机**
>* 79. **让`iOS`应用直接退出**
>* 86. **屏幕截图**
>* 94. **递归缩放包含矢量内容的视图，防止模糊和锯齿**
>* 95. **判断某个点是否在『视图区域』内,避免`Rotation`形变手势带来的`frame`差错**

* **
>###常用宏
>* 23. **常用宏**


```swift
1. `UITableView` 的 `Group` 样式下顶部空白处理
2. `UITableView` 的 `plain`样式下，取消区头停滞效果
3. 获取某个 `view` 所在的控制器
4. 两种方法删除 `NSUserDefaults` 所有记录
5. 打印系统所有已注册的字体名称
6. 获取图片某一点的颜色
7. 字符串反转
8. 禁止锁屏
9. 模态推出一个透明界面
10. 显示／隐藏文件
11. 字符串按多个符号分割
12. iOS跳转到 `App Store` 下载应用评分
13. iOS 获取汉字的拼音
14. 手动更改 iOS 状态栏的颜色
15. 判断当前 `ViewController` 是 `push` 还是 `present` 的方式显示的
16. 获取实际使用的 `LaunchImage` 图片
17. 判断对象是否遵循了某协议
18. 判断 `view` 是不是指定视图的子视图
19. `NSArray` 快速求总和 最大值 最小值 和 平均值
20. 修改 `UITextField` 中 `Placeholder` 的文字颜色
21. 关于 `NSDateFormatter` 的格式
22. 获取一个类的所有子类
23. 常用宏
24. 阿拉伯数字转中文格式
25. `Base64` 编码与 `NSString` 对象或 `NSData` 对象的转换
26. 取消 `UICollectionView` 的隐式动画
27. `UIImage` 占用内存大小
28. `GCD timer` 定时器
29. 图片上绘制文字
30. 查找一个视图的所有子视图
31. 计算文件/文件夹大小
32. `UIView` 设置部分圆角
33. 取上整与取下整
34. 计算字符串字符长度，一个汉字算两个字符
35. 给 `UIView` 设置图片
36. 防止 `scrollView` 手势覆盖侧滑手势
37. 去掉导航栏返回的 `back` 标题,只剩下箭头
38. 字符串中是否含有中文
39. `UITextField` 每四位加一个空格代理方法
40. 获取私有属性和成员变量 `#import <objc/runtime.h>`
41. 获取手机安装的应用信息
42. 判断两个日期是否在同一周(写在 `NSDate` 的 `category` 里面)
43. 应用内打开系统设置界面
44. 屏蔽触发事件，2 秒后取消屏蔽(没有透明阴影效果，一片白)
45. `fillRule` 原理
46. `iOS`中数字的格式化
47. 如何获取 `WebView` 所有的图片地址
48. 获取到 `webview` 的高度
49. 利用 `LLDB` 打印 `View` 所有子视图
50. `navigationBar` 变为纯透明
51. `tabBar` 变为纯透明
52. `navigationBar` 根据滑动距离的渐变色实现
53. `iOS` 开发中一些相关的路径
54. `navigationItem` 的 `BarButtonItem` 如何紧靠屏幕右边界或者左边界？
55. `NSString` 进行 `URL` 编码和解码
56. `UIWebView` 设置 `User-Agent`
57. 获取硬盘总容量与可用容量
58. 获取 `UIColor` 的 `RGBA` 值
59. 修改 `textField` 的 `placeholder` 的字体颜色、大小
60. `AFN `移除 `JSON` 中的 `NSNull`
61. `UIWebView `里面的图片自适应屏幕
62. 手机号码匹配
63. 邮箱匹配
64. `base64` 加密
65. 时间戳转换成指定格式的日期
66. 日期转换成时间戳
67. 判断输入的是否是有效数字
68. 十六进制颜色转换成 `UIColor`
69. `UITextField` 截断字符串。
70. 打开手机 `QQ` 与指定人聊天。
71. 一些控件没有 `setBackgroundImage` 方法的可以用这个设置背景图片
72. 设置震动和声音
73. 删除所有子控件
74. `NSString` 过滤特殊字符
75. `app`提交审核上架关于 `IDFA` 广告标识符——`IDFA(identifier for advertising)`
76. `iOS`项目里加载本地 `HTML`
77. `layoutSubviews`调用的调用时机
78. 使 `tableViewCell`分割线的两头都接触边缘
79. 让`iOS`应用直接退出
80. 设置`Label`中不同文字的颜色
81. 播放声音
82. 调整`Label`行间距
83. `UIImageView`填充模式
84. 设置状态栏文字的样式/颜色
85. 字符串除去空格需求，转变字母大小写
86. 屏幕截图
87. 动态设置导航条`hidden`
88. 图片拉伸
89. 去掉导航栏/tabBar上的黑线
90. `UIImage`与字符串互转
91. `NSDate`与`NSString`的相互转化
92. `UIWebView`退出时，使音频停止播放
93. 头部视图放大
94. 递归缩放包含矢量内容的视图，防止模糊和锯齿
95. 判断某个点是否在『视图区域』内,避免`Rotation`形变手势带来的`frame`差错
```

###1.`UITableView`的`Group`样式下顶部空白处理
* **思路：**将`headerView`赋值一个空白的`view`,与取消底部多余线条方法类似类似

```swift
 UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0.1)]; 
 self.tableView.tableHeaderView = view;
 // 或者在返回头部高度的代理方法中返回 0.1 ，0 没用。
```

###2.`UITableView`的`plain`样式下，取消区头停滞效果
* **注意：**经测试，向上滚动`scrollView.contentOffset.y`增大，向下滚动，该值减小。
* **思路：**拿到区头的高度，如果 y 值小于等于区头的高度，并且大于 0 ，扩充向上滚动的范围，到区头高度的距离。如果 y 值大于等于区头的高度,扩充的滚动范围不变
* **原理：**通过增加`scrollView`的额外滚动区域，将区头遮挡住。

```swift
- (void)scrollViewDidScroll:(UIScrollView *)scrollView {    
	CGFloat sectionHeaderHeight = sectionHead.height; 
	 if (scrollView.contentOffset.y <= sectionHeaderHeight&&scrollView.contentOffset.y >= 0) {        
	   	scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
	 }else if(scrollView.contentOffset.y >= sectionHeaderHeight) {        
	   	scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);   
	 } 
}
```

###3.获取某个`view`所在的控制器
* **原理：** `UIResponder`响应类，事件在被触发时逐渐向上传递，最后找到要处理该事件的响应者，借助该原理找到第一个继承自`UIViewController`的控制器，便是该`view`的控制器。

```swift
- (UIViewController *)viewController {  
	UIViewController *viewController = nil;    
	UIResponder *next = self.nextResponder;  
	while (next)  {    
		if ([next isKindOfClass:[UIViewController class]]) {      
			viewController = (UIViewController *)next;
			break;        
		}        
		next = next.nextResponder;    
	}    
	return viewController; 
}
```
###4.两种方法删除`NSUserDefaults`所有记录

```swift
//方法一
NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];
[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; 

//方法二 
- (void)resetDefaults {    
  	NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];
  	NSDictionary * dict = [defs dictionaryRepresentation];  
  	for (id key in dict)    {       
  		[defs removeObjectForKey:key];   
  	}    
  	[defs synchronize]; 
}
```

###5.打印系统所有已注册的字体名称
```swift
#pragma mark - 打印系统所有已注册的字体名称 
void enumerateFonts() {    
	for (NSString *familyName in [UIFont familyNames])   {        
		NSLog(@"%@",familyName);                      
		NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];
   		for(NSString *fontName in fontNames)       {            
   			NSLog(@"\t|- %@",fontName);       
   		}   
   	} 
}
```

###6.获取图片某一点的颜色
```swift
- (UIColor *)getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image {    
	UIColor* color = nil;    
	CGImageRef inImage = image.CGImage;    
	CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];    
	if (cgctx == NULL) {        
		return nil; /* error */    
	}    
	size_t w = CGImageGetWidth(inImage);    
	size_t h = CGImageGetHeight(inImage);    
	CGRect rect = {{0,0},{w,h}};    
	CGContextDrawImage(cgctx, rect, inImage);    
	unsigned char* data = CGBitmapContextGetData (cgctx);    
	if (data != NULL) {        
		int offset = 4*((w*round(point.y))+round(point.x));        
		int alpha =  data[offset];        
		int red = data[offset+1];        
		int green = data[offset+2];        
		int blue = data[offset+3];        
		color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:(blue/255.0f) alpha:(alpha/255.0f)];    
	}    
	CGContextRelease(cgctx);    
	if (data) {        
		free(data);    
	}    
	return color; 
}
```
###7.字符串反转
```swift
第一种： 
- (NSString *)reverseWordsInString:(NSString *)str {        
	NSMutableString *newString = [[NSMutableString alloc] initWithCapacity:str.length];    
	for (NSInteger i = str.length - 1; i >= 0 ; i --)    {        
		unichar ch = [str characterAtIndex:i];              
		[newString appendFormat:@"%c", ch];        
	}         
	return newString; 
} 
//第二种： 
- (NSString*)reverseWordsInString:(NSString*)str {         
	NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length];        
	[str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences  usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {          
		[reverString appendString:substring];                              
	}];         
	return reverString; 
}
```
###8.禁止锁屏
* 默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。

```swift
[UIApplication sharedApplication].idleTimerDisabled = YES; 
或 
[[UIApplication sharedApplication] setIdleTimerDisabled:YES];
```
###9.模态推出一个透明界面

```swift
UIViewController *vc = [[UIViewController alloc] init];
UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc]; 
if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 8.0) {     
 	na.modalPresentationStyle = UIModalPresentationOverCurrentContext; 
} else {     
 	self.modalPresentationStyle = UIModalPresentationCurrentContext; 
} 
[self presentViewController:na animated:YES completion:nil];
```
###10.显示／隐藏文件
* 显示 `defaults write com.apple.finder AppleShowAllFiles -bool true killall Finder`
* 隐藏 `defaults write com.apple.finder AppleShowAllFiles -bool false killall Finder`

###11.字符串按多个符号分割
```swift
NSString *str = @"abc,vfr.yyuu";
NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@",."];
NSLog(@"%@",[str componentsSeparatedByCharactersInSet:set]);
```
###12.iOS跳转到`App Store`下载应用评分
```swift
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&id=APPID"]];
```
###13.iOS 获取汉字的拼音
```swift
+ (NSString *)transform:(NSString *)chinese {        
  	//将NSString装换成NSMutableString    
  	NSMutableString *pinyin = [chinese mutableCopy];        
  	//将汉字转换为拼音(带音标)        
  	CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);        
  	NSLog(@"%@", pinyin);        
  	//去掉拼音的音标        
  	CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);        
  	NSLog(@"%@", pinyin);        
  	//返回最近结果        
  	return pinyin; 
}
```
###14.手动更改iOS状态栏的颜色
```swift
- (void)setStatusBarBackgroundColor:(UIColor *)color {    
	UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@"statusBarWindow"] valueForKey:@"statusBar"];    
	if ([statusBar respondsToSelector:@selector(setBackgroundColor:)])    {        
		statusBar.backgroundColor = color;        
	} 
}
```
###15.判断当前`ViewController`是`push`还是`present`的方式显示的
```swift
NSArray *viewcontrollers=self.navigationController.viewControllers; 
if (viewcontrollers.count > 1) {    
	if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self)    {        
		//push方式       
		[self.navigationController popViewControllerAnimated:YES];    
	} 
} else {    
	//present方式    
	[self dismissViewControllerAnimated:YES completion:nil]; 
}
```
###16.获取实际使用的`LaunchImage`图片
```swift
- (NSString *)getLaunchImageName {    
	CGSize viewSize = self.window.bounds.size;    
	// 竖屏        
	NSString *viewOrientation = @"Portrait";      
	NSString *launchImageName = nil;        
	NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@"UILaunchImages"];    
	for (NSDictionary* dict in imagesDict)    {        
		CGSize imageSize = CGSizeFromString(dict[@"UILaunchImageSize"]);        
		if (CGSizeEqualToSize(imageSize, viewSize) && [viewOrientation isEqualToString:dict[@"UILaunchImageOrientation"]])        {            
			launchImageName = dict[@"UILaunchImageName"];                
		  }        
	}        
	return launchImageName; 
}
```
###17.判断对象是否遵循了某协议
```swift
if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)]) {     
	[self.selectedController performSelector:@selector(onTriggerRefresh)]; 
}
```
###18.判断`view`是不是指定视图的子视图
```swift
BOOL isView = [textView isDescendantOfView:self.view];
```
###19.NSArray 快速求总和 最大值 最小值 和 平均值
```swift
NSArray *array = [NSArray arrayWithObjects:@"2.0", @"2.3", @"3.0", @"4.0", @"10", nil];
    //总和
    CGFloat sum = [[array valueForKeyPath:@"@sum.floatValue"] floatValue];
    //平均值
    CGFloat avg = [[array valueForKeyPath:@"@avg.floatValue"] floatValue];
    //最大值
    CGFloat max =[[array valueForKeyPath:@"@max.floatValue"] floatValue];
    //最小值
    CGFloat min =[[array valueForKeyPath:@"@min.floatValue"] floatValue];
    NSLog(@"%f\n%f\n%f\n%f",sum,avg,max,min);
```
###20.修改`UITextField`中`Placeholder`的文字颜色
```swift
[textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"];
```
###21.关于`NSDateFormatter`的格式
```swift
G: 公元时代，例如AD公元 
yy: 年的后2位 
yyyy: 完整年 
MM: 月，显示为1-12 
MMM: 月，显示为英文月份简写,如 Jan 
MMMM: 月，显示为英文月份全称，如 Janualy 
dd: 日，2位数表示，如02 
d: 日，1-2位显示，如 2 
EEE: 简写星期几，如Sun 
EEEE: 全写星期几，如Sunday 
aa: 上下午，AM/PM 
H: 时，24小时制，0-23 
K：时，12小时制，0-11 
m: 分，1-2位 
mm: 分，2位 
s: 秒，1-2位 
ss: 秒，2位 
S: 毫秒
```
###22.获取一个类的所有子类
```swift
+ (NSArray *) allSubclasses
{
    Class myClass = [self class];
    NSMutableArray *mySubclasses = [NSMutableArray array];
    unsigned int numOfClasses;
    Class *classes = objc_copyClassList(&numOfClasses;);
    for (unsigned int ci = 0; ci < numOfClasses; ci++)
    {
        Class superClass = classes[ci];
        do{
            superClass = class_getSuperclass(superClass);
        } while (superClass && superClass != myClass);

        if (superClass)
        {
            [mySubclasses addObject: classes[ci]];
        }
    }
    free(classes);
    return mySubclasses;
}
```
###23.常用宏
```swift
//字符串是否为空
#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] < 1 ? YES : NO )
//数组是否为空
#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)
//字典是否为空
#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)
//是否是空对象
#define kObjectIsEmpty(_object) (_object == nil \
|| [_object isKindOfClass:[NSNull class]] \
|| ([_object respondsToSelector:@selector(length)] && [(NSData *)_object length] == 0) \
|| ([_object respondsToSelector:@selector(count)] && [(NSArray *)_object count] == 0))

//获取屏幕宽度与高度
#define kScreenWidth \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.width)
#define kScreenHeight \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.height)
#define kScreenSize \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale) : [UIScreen mainScreen].bounds.size)

//一些缩写
#define kApplication        [UIApplication sharedApplication]
#define kKeyWindow          [UIApplication sharedApplication].keyWindow
#define kAppDelegate        [UIApplication sharedApplication].delegate
#define kUserDefaults       [NSUserDefaults standardUserDefaults]
#define kNotificationCenter [NSNotificationCenter defaultCenter]

//APP版本号
#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]
//系统版本号
#define kSystemVersion [[UIDevice currentDevice] systemVersion]
// 系统版本号ios8以上
#define kIsIOS8Later ([[[UIDevice currentDevice] systemVersion] floatValue] >= 8.0)
//获取当前语言
#define kCurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])
//判断是否为iPhone
#define kISiPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
//判断是否为iPad
#define kISiPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)

//获取沙盒Document路径
#define kDocumentPath [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
//获取沙盒temp路径
#define kTempPath NSTemporaryDirectory()
//获取沙盒Cache路径
#define kCachePath [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]

//判断是真机还是模拟器
#if TARGET_OS_IPHONE
//真机
#endif

#if TARGET_IPHONE_SIMULATOR
//模拟器
#endif

//开发的时候打印，但是发布的时候不打印的NSLog
#ifdef DEBUG
#define NSLog(...) NSLog(@"%s 第%d行 \n %@\n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])
#else
#define NSLog(...)
#endif

//颜色
#define kRGBColor(r, g, b)     [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]
#define kRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]
#define kRandomColor           kRGBColor(arc4random_uniform(256),arc4random_uniform(256),arc4random_uniform(256))

#define kColorWithHex(rgbValue) \
[UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16)) / 255.0 \
green:((float)((rgbValue & 0xFF00) >> 8)) / 255.0 \
blue:((float)(rgbValue & 0xFF)) / 255.0 alpha:1.0]

//弱引用/强引用
#define kWeakSelf(type)   __weak typeof(type) weak##type = type;
#define kStrongSelf(type) __strong typeof(type) type = weak##type;

#define WeakSelf(weakSelf)  __weak __typeof(&*self) weakSelf = self

//由角度转换弧度
#define kDegreesToRadian(x)      (M_PI * (x) / 180.0)
//由弧度转换角度
#define kRadianToDegrees(radian) (radian * 180.0) / (M_PI)

//获取一段时间间隔
#define kStartTime CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();
#define kEndTime   NSLog(@"Time: %f", CFAbsoluteTimeGetCurrent() - start)
```
###24.阿拉伯数字转中文格式
```swift
+(NSString *)translation:(NSString *)arebic
{  
    NSString *str = arebic;
    NSArray *arabic_numerals = @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"0"];
    NSArray *chinese_numerals = @[@"一",@"二",@"三",@"四",@"五",@"六",@"七",@"八",@"九",@"零"];
    NSArray *digits = @[@"个",@"十",@"百",@"千",@"万",@"十",@"百",@"千",@"亿",@"十",@"百",@"千",@"兆"];
    NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals];

    NSMutableArray *sums = [NSMutableArray array];
    for (int i = 0; i < str.length; i ++) {
        NSString *substr = [str substringWithRange:NSMakeRange(i, 1)];
        NSString *a = [dictionary objectForKey:substr];
        NSString *b = digits[str.length -i-1];
        NSString *sum = [a stringByAppendingString:b];
        if ([a isEqualToString:chinese_numerals[9]])
        {
            if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]])
            {
                sum = b;
                if ([[sums lastObject] isEqualToString:chinese_numerals[9]])
                {
                    [sums removeLastObject];
                }
            }else
            {
                sum = chinese_numerals[9];
            }

            if ([[sums lastObject] isEqualToString:sum])
            {
                continue;
            }
        }

        [sums addObject:sum];
    }

    NSString *sumStr = [sums componentsJoinedByString:@""];
    NSString *chinese = [sumStr substringToIndex:sumStr.length-1];
    NSLog(@"%@",str);
    NSLog(@"%@",chinese);
    return chinese;
}
```
###25.`Base64`编码与`NSString`对象或`NSData`对象的转换
```swift
// 转 Base64
NSData *nsdata = [@"iOS Developer Tips encoded in Base64" dataUsingEncoding:NSUTF8StringEncoding];
NSString *base64Encoded = [nsdata base64EncodedStringWithOptions:0];
NSLog(@"Encoded: %@", base64Encoded);

// 转回 String
NSData *nsdataFromBase64String = [[NSData alloc] initWithBase64EncodedString:base64Encoded options:0];
NSString *base64Decoded = [[NSString alloc] initWithData:nsdataFromBase64String encoding:NSUTF8StringEncoding];
NSLog(@"Decoded: %@", base64Decoded);
```
###26.取消`UICollectionView`的隐式动画
* `UICollectionView`在`reloadItems`的时候，默认会附加一个隐式的`fade`动画，有时候很讨厌，尤其是当你的`cell`是复合`cell`的情况下(比如`cell`使用到了`UIStackView`)。

```swift
下面几种方法都可以帮你去除这些动画

//方法一
[UIView performWithoutAnimation:^{
    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
}];

//方法二
[UIView animateWithDuration:0 animations:^{
    [collectionView performBatchUpdates:^{
        [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
    } completion:nil];
}];

//方法三
[UIView setAnimationsEnabled:NO];
[self.trackPanel performBatchUpdates:^{
    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:^(BOOL finished) {
    [UIView setAnimationsEnabled:YES];
}];

```
###27.`UIImage` 占用内存大小
```swift
UIImage *image = [UIImage imageNamed:@"aa"]; 
NSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);
```
###28.GCD `timer`定时器
```swift
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行
dispatch_source_set_event_handler(timer, ^{
    //@"倒计时结束，关闭"
    dispatch_source_cancel(timer); 
    dispatch_async(dispatch_get_main_queue(), ^{

    });
});
dispatch_resume(timer);
```
###29.图片上绘制文字
```swift
- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize
{
    //画布大小
    CGSize size=CGSizeMake(self.size.width,self.size.height);
    //创建一个基于位图的上下文
    UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO  scale:0.0

    [self drawAtPoint:CGPointMake(0.0,0.0)];

    //文字居中显示在画布上
    NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
    paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping;
    paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中

    //计算文字所占的size,文字居中显示在画布上
    CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin
                                     attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size;
    CGFloat width = self.size.width;
    CGFloat height = self.size.height;

    CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height);
    //绘制文字
    [title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}];

    //返回绘制的新图形
    UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
```
###30.查找一个视图的所有子视图
```swift
- (NSMutableArray *)allSubViewsForView:(UIView *)view
{
    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];
    for (UIView *subView in view.subviews)
    {
        [array addObject:subView];
        if (subView.subviews.count > 0)
        {
            [array addObjectsFromArray:[self allSubViewsForView:subView]];
        }
    }
    return array;
}
```
###31.计算文件/文件夹大小
```swift
//文件大小
- (long long)fileSizeAtPath:(NSString *)path
{
    NSFileManager *fileManager = [NSFileManager defaultManager];

    if ([fileManager fileExistsAtPath:path])
    {
        long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize;
        return size;
    }

    return 0;
}

//文件夹大小
- (long long)folderSizeAtPath:(NSString *)path
{
    NSFileManager *fileManager = [NSFileManager defaultManager];

    long long folderSize = 0;

    if ([fileManager fileExistsAtPath:path])
    {
        NSArray *childerFiles = [fileManager subpathsAtPath:path];
        for (NSString *fileName in childerFiles)
        {
            NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName];
            if ([fileManager fileExistsAtPath:fileAbsolutePath])
            {
                long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize;
                folderSize += size;
            }
        }
    }

    return folderSize;
}
// 文件／文件夹
- (float)fileSizeAtPath:(NSString *)Path{ 
	//文件管理者 
	NSFileManager *mgr = [NSFileManager defaultManager]; 
	//判断字符串是否为文件/文件夹 
	BOOL dir = NO; 
	BOOL exists = [mgr fileExistsAtPath:Path isDirectory:&dir]; 
	//文件/文件夹不存在 
	if (exists == NO) return 0; 
	//path是文件夹 
	if (dir){ 
		//遍历文件夹中的所有内容 
		NSArray *subpaths = [mgr subpathsAtPath:Path]; 
		//计算文件夹大小 
		float totalByteSize = 0; 
		for (NSString *subpath in subpaths){ 
			//拼接全路径 
			NSString *fullSubPath = [Path stringByAppendingPathComponent:subpath]; 
			//判断是否为文件 
			BOOL dir = NO; 
			[mgr fileExistsAtPath:fullSubPath isDirectory:&dir]; 
			if (dir == NO){
				//是文件 
				NSDictionary *attr = [mgr attributesOfItemAtPath:fullSubPath error:nil]; 
				totalByteSize += [attr[NSFileSize] floatValue]; 
			} 
		} 
		return totalByteSize/(1024.0*1024.0); 
	} else{
		//是文件 
		NSDictionary *attr = [mgr attributesOfItemAtPath:Path error:nil]; 
		return [attr[NSFileSize] floatValue]/(1024.0*1024.0); 
	} 
}
```
###32.UIView设置部分圆角
```swift
CGRect rect = view.bounds; 
CGSize radio = CGSizeMake(30, 30);//圆角尺寸 
UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//这只圆角位置 
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio]; 
CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayer masklayer.frame = view.bounds; 
masklayer.path = path.CGPath;//设置路径 
view.layer.mask = masklayer;
```
###33.取上整与取下整
* 取上整：即取不大于x的最大整数
 * `floor()`功 能：返回小于或者等于指定表达式的最大整数
* 取下整：不小于给定实数的最小整数
 * `ceil()`功 能：返回大于或者等于指定表达式的最小整数

```swift
floor(x),有时候也写做Floor(x)，其功能是“下取整”，即取不大于x的最大整数 
例如：x = 3.14，floor(x) = 3 
y = 9.99999，floor(y) = 9 

与floor函数对应的是ceil函数，即上取整函数。 

ceil函数的作用是求不小于给定实数的最小整数。 
ceil(2) = ceil(1.2) = cei(1.5) = 2.00 

floor函数与ceil函数的返回值均为double型
```
###34.计算字符串字符长度，一个汉字算两个字符

```swift
//方法一：
- (int)convertToInt:(NSString*)strtemp
{
    int strlength = 0;
    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
    for (int i=0 ; i<[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++)
    {
        if (*p)
        {
            p++;
            strlength++;
        }
        else
        {
            p++;
        }

    }
    return strlength;
}
//方法二：
- (NSUInteger)unicodeLengthOfString:(NSString *)text
{
    NSUInteger asciiLength = 0;
    for (NSUInteger i = 0; i < text.length; i++)
    {
        unichar uc = [text characterAtIndex: i];
        asciiLength += isascii(uc) ? 1 : 2;
    }
    return asciiLength;
}
```
###35.给`UIView`设置图片

```swift
UIImage *image = [UIImage imageNamed:@"image"];
self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage); 
self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);
```
###36.防止`scrollView`手势覆盖侧滑手势

```swift
[scrollView.panGestureRecognizer requireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer];
```
###37.去掉导航栏返回的`back`标题,只剩下箭头
```swift
//Swift
UIBarButtonItem.appearance().setBackButtonTitlePositionAdjustment(UIOffsetMake(0, -60), forBarMetrics: .Default)
//OC
[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];

```
###38.字符串中是否含有中文
```swift
+ (BOOL)checkIsChinese:(NSString *)string
{
    for (int i=0; i<string.length; i++)
    {
        unichar ch = [string characterAtIndex:i];
        if (0x4E00 <= ch  && ch <= 0x9FA5)
        {
            return YES;
        }
    }
    return NO;
}
```
###39.`UITextField`每四位加一个空格代理方法
```swift
- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string
{
    // 四位加一个空格
    if ([string isEqualToString:@""])
    {
        // 删除字符
        if ((textField.text.length - 2) % 5 == 0)
        {
            textField.text = [textField.text substringToIndex:textField.text.length - 1];
        }
        return YES;
    }
    else
    {
        if (textField.text.length % 5 == 0)
        {
            textField.text = [NSString stringWithFormat:@"%@ ", textField.text];
        }
    }
    return YES;
}
```
###40.获取私有属性和成员变量 `#import <objc/runtime.h>`
```swift
//获取私有属性 比如设置UIDatePicker的字体颜色
- (void)setTextColor
{
    //获取所有的属性，去查看有没有对应的属性
    unsigned int count = 0;
    objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], &count);
    for(int i = 0;i < count;i ++)
    {
        //获得每一个属性
        objc_property_t property = propertys[i];
        //获得属性对应的nsstring
        NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
        //输出打印看对应的属性
        NSLog(@"propertyname = %@",propertyName);
        if ([propertyName isEqualToString:@"textColor"])
        {
            [datePicker setValue:[UIColor whiteColor] forKey:propertyName];
        }
    }
}
//获得成员变量 比如修改UIAlertAction的按钮字体颜色
unsigned int count = 0;
Ivar *ivars = class_copyIvarList([UIAlertAction class], &count);
for(int i =0;i < count;i ++)
{
    Ivar ivar = ivars[i];
    NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding];
    NSLog(@"uialertion.ivarName = %@",ivarName);
    if ([ivarName isEqualToString:@"_titleTextColor"])
    {
        [alertOk setValue:[UIColor blueColor] forKey:@"titleTextColor"];
        [alertCancel setValue:[UIColor purpleColor] forKey:@"titleTextColor"];
     }
}

```
###41.获取手机安装的应用信息
* 在我们的`info.plist`里面经常看到这两个关键字，其中`CFBundleShortVersionString`是针对上线的版本的，如果你要上线一个新版本，那么必须后一个版本号大于前面一个，就是`CFBundleShortVersionString`的数字，但是`CFBundleVersion`是针对编译版本的，如果你得版本1.1被打回了，不需要去修改`CFBundleShortVersionString`的值，只需要修改`CFBundleVersion`的值递增以下就 OK 了

```swift
Class c =NSClassFromString(@"LSApplicationWorkspace");
id s = [(id)c performSelector:NSSelectorFromString(@"defaultWorkspace")];
NSArray *array = [s performSelector:NSSelectorFromString(@"allInstalledApplications")];
for (id item in array)
{

    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"applicationIdentifier")]);
    // NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleIdentifier")]);
    // 应用 bundleID
    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleVersion")]);
    // 版本号
    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"shortVersionString")]);
}
```

###42.判断两个日期是否在同一周(写在`NSDate`的`category`里面)

```swift
- (BOOL)isSameDateWithDate:(NSDate *)date
{
    //日期间隔大于七天之间返回NO
    if (fabs([self timeIntervalSinceDate:date]) >= 7 * 24 *3600)
    {
        return NO;
    }

    NSCalendar *calender = [NSCalendar currentCalendar];
    calender.firstWeekday = 2;//设置每周第一天从周一开始
    //计算两个日期分别为这年第几周
    NSUInteger countSelf = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:self];
    NSUInteger countDate = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:date];

    //相等就在同一周，不相等就不在同一周
    return countSelf == countDate;
}
```
###43.打开系统设置界面、打电话、打开网址、发邮件、发短信等
* **注意：**`openURL`在 iOS10 改为 `openURL:options:completionHandler:`。

>####打电话
>```swift
>// 以下方法 tel:// 或者 tel: 都行
>// 第一种：常见用法，亲测在电话拨打完后都不会停留在电话界面，都有提示，没什么区别。
>[[UIApplication sharedApplication] openURL:[[NSURL alloc]initWithString:@"tel://10086"]];
>
>// 第二种：私有方法，可能不能通过审核
[[UIApplication sharedApplication] openURL:[[NSURL alloc]initWithString:@"telprompt://10086"]];
>
// 第三种：注意：webView 要是全局变量才有效
_web = [[UIWebView alloc]initWithFrame:CGRectZero];
[_web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"tel://10086"]]];
>```


>####发短信
>```swift
>// 方式一：调用系统软件发短信，取消发送不会返回原软件
>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"sms://10010"]];
>
>
>// 方式二：可以监听发短信的各个步骤，取消发送会返回原软件，可以直接指定短信内容
>#import <MessageUI/MessageUI.h>
>- (void)viewDidLoad {
    [super viewDidLoad];
    //    显示发短信的控制器
    MFMessageComposeViewController *vc = [[MFMessageComposeViewController alloc] init];
    //    设置短信内容
    vc.body = @"吃饭了没？";
    //    设置收件人列表
    vc.recipients = @[@"10010", @"02010010"];
    //    设置代理
    vc.messageComposeDelegate = self;
    //    显示控制器
    [self presentViewController:vc animated:YES completion:nil];
}
    //代理方法，当短信界面关闭的时候调用，发完后会自动回到原应用
- (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result
{
//    关闭短信界面
    [controller dismissViewControllerAnimated:YES completion:nil];
    if (result == MessageComposeResultCancelled) {
        NSLog(@"取消发送");
    } else if (result == MessageComposeResultSent) {
        NSLog(@"已经发出");
    } else {
        NSLog(@"发送失败");
    }
}
>```
>####发邮件
>```swift
>// 方式一：调用系统软件，取消发送不会返回原软件
>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"mailto://10010@qq.com"]];
>
>
>// 方式二：可以监听发短信的各个步骤，取消发送会返回原软件，可以直接指定短信内容
- (void)viewDidLoad {
    [super viewDidLoad];
    if (![MFMailComposeViewController canSendMail]) {
        // 检查邮件功能是否已经打开
        return;
    }
    //    显示发短信的控制器
    MFMailComposeViewController *vc = [[MFMailComposeViewController alloc] init];
    //    设置代理
    vc.mailComposeDelegate = self;
    
>    //    主题／邮件title
    [vc setSubject:@"10010@qq.com"];
    //    内容
    [vc setMessageBody:@"fdsdf" isHTML:NO];
    //    设置收件地址(会自动检测地址格式)
    //    发件箱地址默认是你的iphone手机的设置邮件地址
    [vc setToRecipients:@[@"", @"sijin2217@126.com"]];
    // 添加图片
    UIImage *addPic = [UIImage imageNamed:@"Icon.png"];
    NSData *imageData = UIImagePNGRepresentation(addPic);
    [vc addAttachmentData:imageData mimeType:@"" fileName:@"Icon.png"];
    
>    //    显示控制器
    [self presentViewController:vc animated:YES completion:nil];
}
// 代理监听方法
- (void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error
{
//    关闭邮件界面
    [controller dismissViewControllerAnimated:YES completion:nil];
    NSString *msg;
    switch (result)
    {
        case MFMailComposeResultCancelled:
            msg = @"邮件发送取消";
            break;
        case MFMailComposeResultSaved:
            msg = @"邮件保存成功";
            break;
        case MFMailComposeResultSent:
            msg = @"邮件发送成功";
            break;
        case MFMailComposeResultFailed:
            msg = @"邮件发送失败";
            break;
        default:
            break;
    }
}
>```

* **浏览器：** `[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@"http://www.baidu.com"]]`; 
* **Email：** `[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@"mailto://"]]`; 
* **系统设置：** `[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@"prefs:root=WIFI"]]`;

```swift
//iOS8之后
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
//如果App没有添加权限，显示的是设定界面。如果App有添加权限（例如通知），显示的是App的设定界面。

//iOS8之前
//先添加一个url type如下图，在代码中调用如下代码,即可跳转到设置页面的对应项
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"prefs:root=WIFI"]];

可选值如下：
About — prefs:root=General&path=About
Accessibility — prefs:root=General&path=ACCESSIBILITY
Airplane Mode On — prefs:root=AIRPLANE_MODE
Auto-Lock — prefs:root=General&path=AUTOLOCK
Brightness — prefs:root=Brightness
Bluetooth — prefs:root=General&path=Bluetooth
Date & Time — prefs:root=General&path=DATE_AND_TIME
FaceTime — prefs:root=FACETIME
General — prefs:root=General
Keyboard — prefs:root=General&path=Keyboard
iCloud — prefs:root=CASTLE
iCloud Storage & Backup — prefs:root=CASTLE&path=STORAGE_AND_BACKUP
International — prefs:root=General&path=INTERNATIONAL
Location Services — prefs:root=LOCATION_SERVICES
Music — prefs:root=MUSIC
Music Equalizer — prefs:root=MUSIC&path=EQ
Music Volume Limit — prefs:root=MUSIC&path=VolumeLimit
Network — prefs:root=General&path=Network
Nike + iPod — prefs:root=NIKE_PLUS_IPOD
Notes — prefs:root=NOTES
Notification — prefs:root=NOTIFICATI*****_ID
Phone — prefs:root=Phone
Photos — prefs:root=Photos
Profile — prefs:root=General&path=ManagedConfigurationList
Reset — prefs:root=General&path=Reset
Safari — prefs:root=Safari
Siri — prefs:root=General&path=Assistant
Sounds — prefs:root=Sounds
Software Update — prefs:root=General&path=SOFTWARE_UPDATE_LINK
Store — prefs:root=STORE
Twitter — prefs:root=TWITTER
Usage — prefs:root=General&path=USAGE
VPN — prefs:root=General&path=Network/VPN
Wallpaper — prefs:root=Wallpaper
Wi-Fi — prefs:root=WIFI
```
![](/Users/liuzhigao/Desktop/自定义转场动画/18310844-99EE-493C-90AC-F691B4CD4FBA.png)
###44.屏蔽触发事件，2秒后取消屏蔽(该屏遮没有透明阴影效果，一片白)

```swift
[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [[UIApplication sharedApplication] endIgnoringInteractionEvents];
});
```
###45.`fillRule`原理

![](/Users/liuzhigao/Desktop/自定义转场动画/32C60B6F-8294-41BC-A4C8-2B274F31AE2C.png)

###46.iOS中数字的格式化

```swift
//通过NSNumberFormatter，同样可以设置NSNumber输出的格式。例如如下代码： 
NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]; 
formatter.numberStyle = NSNumberFormatterDecimalStyle; 
NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]]; 
NSLog(@"Formatted number string:%@",string); 
//输出结果为：[1223:403] Formatted number string:123,456,789 
//其中NSNumberFormatter类有个属性numberStyle，它是一个枚举型，设置不同的值可以输出不同的数字格式。该枚举包括： 
typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) {     
	NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle,
	NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle,     
	NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle,     
	NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle,     
	NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle,     
	NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle 
}; 
//各个枚举对应输出数字格式的效果如下：其中第三项和最后一项的输出会根据系统设置的语言区域的不同而不同。 
[1243:403] Formatted number string:123456789 
[1243:403] Formatted number string:123,456,789 
[1243:403] Formatted number string:￥123,456,789.00 
[1243:403] Formatted number string:-539,222,988% 
[1243:403] Formatted number string:1.23456789E8 
[1243:403] Formatted number string:一亿二千三百四十五万六千七百八十九
```
###47.如何获取`WebView`所有的图片地址
* 在网页加载完成时，通过 js 获取图片和添加点击的识别方式

```swift
//UIWebView 
- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //这里是js，主要目的实现对url的获取
    static  NSString * const jsGetImages =
    @"function getImages(){\
    var objs = document.getElementsByTagName(\"img\");\
    var imgScr = '';\
    for(var i=0;i<objs.length;i++){\
    imgScr = imgScr + objs[i].src + '+';\
    };\
    return imgScr;\
    };";

    [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法
    NSString *urlResult = [webView stringByEvaluatingJavaScriptFromString:@"getImages()"];
    NSArray *urlArray = [NSMutableArray arrayWithArray:[urlResult componentsSeparatedByString:@"+"]];
    //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组
}
//WKWebView
- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation
{
    static  NSString * const jsGetImages =
    @"function getImages(){\
    var objs = document.getElementsByTagName(\"img\");\
    var imgScr = '';\
    for(var i=0;i<objs.length;i++){\
    imgScr = imgScr + objs[i].src + '+';\
    };\
    return imgScr;\
    };";

    [webView evaluateJavaScript:jsGetImages completionHandler:nil];
    [webView evaluateJavaScript:@"getImages()" completionHandler:^(id _Nullable result, NSError * _Nullable error) {
        NSLog(@"%@",result);
    }];
}
```
###48.获取到`webview`的高度

```swift
CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@"document.body.offsetHeight"] floatValue];
```
###49.利用`LLDB`打印`View`所有子视图
`po [[self view]recursiveDescription]`
###50.`navigationBar`变为纯透明

```swift
//第一种方法 
//导航栏纯透明 
[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; 
//去掉导航栏底部的黑线 
self.navigationBar.shadowImage = [UIImage new]; 
//第二种方法 
[[self.navigationBar subviews] objectAtIndex:0].alpha = 0;
```
* 其他总结

>* **方案一**：包含上面的按钮

>```swift
// 有用，上面的按钮还会显示
- (void)setNavgationBarClear{
    self.navigationController.navigationBar.translucent = YES;
    CGRect rect = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 64);
    UIColor *color = [UIColor clearColor];
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    // 用 UIBarMetricsCompact 会失效，image可以直接使用 [UIImage new],不要太复杂。
    [self.navigationController.navigationBar setBackgroundImage:image forBarMetrics:UIBarMetricsDefault];
    [self.navigationController.navigationBar setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:[UIColor whiteColor],NSForegroundColorAttributeName,nil]];
}
// 简化
- (void)setNavgationBarClear2{
	self.navigationController.navigationBar.translucent = YES;
	[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];//
    self.navigationController.navigationBar.shadowImage = [[UIImage alloc] init];
    [self.navigationController.navigationBar setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:[UIColor whiteColor],NSForegroundColorAttributeName,nil]];
}
// 取消导航条透明效果
 	// 该效果会直接将导航条变成白色，取消了系统自带的半透明效果
    self.navigationController.navigationBar.translucent = NO;
    [self.navigationController.navigationBar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault];
    [self.navigationController.navigationBar setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys:[UIColor blackColor],NSForegroundColorAttributeName,nil]];
>```

>* **方案二：**
> * `self.navigationController.navigationBar.subviews[0].alpha = 0;`
> 
> * **方案三：**
> 
> ```swift
> [self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[UIImage new]];
>```
     

###51.`tabBar`变为纯透明

```swift
[self.tabBar setBackgroundImage:[UIImage new]];
self.tabBar.shadowImage = [UIImage new];
```
###52.`navigationBar`根据滑动距离的渐变色实现
* 在 **百思不姐** 的笔记中的方法也是有效的

```swift
//第一种
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat offsetToShow = 200.0;//滑动多少就完全显示
    CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;
    [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha;
}
//第二种
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat offsetToShow = 200.0;
    CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;

    [self.navigationController.navigationBar setShadowImage:[UIImage new]];
    [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault];
}

//生成一张纯色的图片
- (UIImage *)imageWithColor:(UIColor *)color
{
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);
    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return theImage;
}
```
###53.iOS 开发中一些相关的路径

```swift
模拟器的位置:
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 

文档安装位置:
/Applications/Xcode.app/Contents/Developer/Documentation/DocSets

插件保存路径:
~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins

自定义代码段的保存路径:
~/Library/Developer/Xcode/UserData/CodeSnippets/ 
如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。

描述文件路径
~/Library/MobileDevice/Provisioning Profiles
```
###54.`navigationItem`的`BarButtonItem`如何紧靠屏幕右边界或者左边界？
* 一般情况下，右边的`item`会和屏幕右侧保持一段距离
* 下面是通过添加一个负值宽度的固定间距的item来解决，也可以改变宽度实现不同的间隔

```swift
UIImage *img = [[UIImage imageNamed:@"icon_cog"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 
//宽度为负数的固定间距的系统item 
UIBarButtonItem *rightNegativeSpacer = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; 
[rightNegativeSpacer setWidth:-15];

UIBarButtonItem *rightBtnItem1 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)]; 
UIBarButtonItem *rightBtnItem2 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)]; 
self.navigationItem.rightBarButtonItems = @[rightNegativeSpacer,rightBtnItem1,rightBtnItem2];
```
###55.`NSString`进行`URL`编码和解码

```swift
NSString *string = @"http://abc.com?aaa=你好&bbb=tttee";

//编码 打印：http://abc.com?aaa=%E4%BD%A0%E5%A5%BD&bbb=tttee
string = [string stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];

//解码 打印：http://abc.com?aaa=你好&bbb=tttee
string = [string stringByRemovingPercentEncoding];
```
###56.`UIWebView`设置`User-Agent`。

```swift
//设置
NSDictionary *dic = @{@"UserAgent":@"your UserAgent"};
[[NSUserDefaults standardUserDefaults] registerDefaults:dic]; 
//获取 
NSString *agent = [self.WebView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];
```
###57.获取硬盘总容量与可用容量

```swift
NSFileManager *fileManager = [NSFileManager defaultManager]; 
NSDictionary *attributes = [fileManager attributesOfFileSystemForPath:NSHomeDirectory() error:nil]; 
NSLog(@"容量%.2fG",[attributes[NSFileSystemSize] doubleValue] / (powf(1024, 3))); 
NSLog(@"可用%.2fG",[attributes[NSFileSystemFreeSize] doubleValue] / powf(1024, 3));
```
###58.获取`UIColor`的`RGBA`值

```swift
UIColor *color = [UIColor colorWithRed:0.2 green:0.3 blue:0.9 alpha:1.0]; 
const CGFloat *components = CGColorGetComponents(color.CGColor); 
NSLog(@"Red: %.1f", components[0]); 
NSLog(@"Green: %.1f", components[1]);
NSLog(@"Blue: %.1f", components[2]); 
NSLog(@"Alpha: %.1f", components[3]);
```
###59.修改`textField`的`placeholder`的字体颜色、大小

```swift
[self.textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"]; 
[self.textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@"_placeholderLabel.font"];
```
###60.`AFN`移除`JSON`中的`NSNull`

```swift
AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
response.removesKeysWithNullValues = YES;
```
###61.`UIWebView`里面的图片自适应屏幕

```swift
- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    NSString *js = @"function imgAutoFit() { \
    var imgs = document.getElementsByTagName('img'); \
    for (var i = 0; i < imgs.length; ++i) { \
    var img = imgs[i]; \
    img.style.maxWidth = %f; \
    } \
    }";

    js = [NSString stringWithFormat:js, [UIScreen mainScreen].bounds.size.width - 20];

    [webView stringByEvaluatingJavaScriptFromString:js];
    [webView stringByEvaluatingJavaScriptFromString:@"imgAutoFit()"];
}
```
###62.手机号码匹配

```swift
// 正则判断手机号码地址格式
- (BOOL)isMobileNumber:(NSString *)mobileNum {

    NSString *MOBILE = @"^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|7[0135678])\\d{8}$";

    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];

    return [regextestmobile evaluateWithObject:mobileNum];
}
```
###63.邮箱匹配

```swift
//邮箱
-(BOOL)isValidateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
```
###64.`base64`加密

```swift
- (NSString *)base64 {
    NSData *data = [NSData dataWithBytes:[self UTF8String] length:[self lengthOfBytesUsingEncoding:NSUTF8StringEncoding]];
    NSUInteger length = [data length];
    NSMutableData *mutableData = [NSMutableData dataWithLength:((length + 2) / 3) * 4];

    uint8_t *input = (uint8_t *)[data bytes];
    uint8_t *output = (uint8_t *)[mutableData mutableBytes];

    for (NSUInteger i = 0; i < length; i += 3) {
        NSUInteger value = 0;
        for (NSUInteger j = i; j < (i + 3); j++) {
            value <<= 8;
            if (j < length) {
                value |= (0xFF & input[j]);
            }
        }

        static uint8_t const kAFBase64EncodingTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        NSUInteger idx = (i / 3) * 4;
        output[idx + 0] = kAFBase64EncodingTable[(value >> 18) & 0x3F];
        output[idx + 1] = kAFBase64EncodingTable[(value >> 12) & 0x3F];
        output[idx + 2] = (i + 1) < length ? kAFBase64EncodingTable[(value >> 6)  & 0x3F] : '=';
        output[idx + 3] = (i + 2) < length ? kAFBase64EncodingTable[(value >> 0)  & 0x3F] : '=';
    }

    return [[NSString alloc] initWithData:mutableData encoding:NSASCIIStringEncoding];
}
```
###65.时间戳转换成指定格式的日期

```swift
-(NSString *)getDateStringWithTimeInterval:(NSString *)timeInterval DataFormatterString:(NSString *)dataFormatterString{
    NSString *dateString;
    NSDateFormatter *dataFormatter = [[NSDateFormatter alloc] init];
    dataFormatter.dateFormat = dataFormatterString;

    NSTimeInterval _interval=[timeInterval doubleValue] / 1000.0;
    NSDate *date = [NSDate dateWithTimeIntervalSince1970:_interval];
    dateString = [dataFormatter stringFromDate:date];

    return dateString;
}
```
###66.日期转换成时间戳

```swift
-(double)getTimeIntervalWithDateString:(NSString *)dateString DataFormatterString:(NSString *)dataFormatterString{
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];

    [formatter setDateStyle:NSDateFormatterMediumStyle];

    [formatter setTimeStyle:NSDateFormatterShortStyle];

    [formatter setDateFormat:dataFormatterString];


    NSDate* date = [formatter dateFromString:dateString];
    //将日期转换成时间戳
    double timeSp = [[NSNumber numberWithDouble:[date timeIntervalSince1970]] doubleValue]*1000;

    return timeSp;

}
```
###67.判断输入的是否是有效数字
* 大于 1

```swift
- (BOOL)isAvildNumber:(NSString *)str{
    NSString *string=@"^[1-9][0-9]*(\\.[0-9]+)?$";
    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", string];
    return [regextestmobile evaluateWithObject:str];
}
```
###68.十六进制颜色转换成UIColor

```swift
//颜色透明度默认为1
+ (UIColor *)colorWithHex:(NSString *)color {

    NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];

    // String should be 6 or 8 characters

    if ([cString length] < 6) {

        return [UIColor clearColor];

    }

    // strip 0X if it appears

    if ([cString hasPrefix:@"0X"])

        cString = [cString substringFromIndex:2];

    if ([cString hasPrefix:@"#"])

        cString = [cString substringFromIndex:1];

    if ([cString length] != 6)

        return [UIColor clearColor];

    // Separate into r, g, b substrings

    NSRange range;

    range.location = 0;

    range.length = 2;

    //r

    NSString *rString = [cString substringWithRange:range];

    //g

    range.location = 2;

    NSString *gString = [cString substringWithRange:range];

    //b

    range.location = 4;

    NSString *bString = [cString substringWithRange:range];

    // Scan values

    unsigned int r, g, b;

    [[NSScanner scannerWithString:rString] scanHexInt:&r];

    [[NSScanner scannerWithString:gString] scanHexInt:&g];

    [[NSScanner scannerWithString:bString] scanHexInt:&b];

    return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:1.0f];

}
```
###69.`UITextField`截断字符串。

```swift
// 设置长度和目标
-(void)limitTextLength:(NSInteger)length TextField:(UITextField *)textfield{
    NSString *toBeString = textfield.text;
    NSString *lang = self.textInputMode.primaryLanguage;
    if ([lang isEqualToString:@"zh-Hans"]) {
        UITextRange *selectedRang = [textfield markedTextRange];
        if (!selectedRang) {
            if (toBeString.length > length) {
                textfield.text = [toBeString substringToIndex:length];
            }
        }else{

        }
    }
    else{
        if (toBeString.length > length) {
            textfield.text = [toBeString substringToIndex:length];
        }
    }

}
```
###70.打开手机QQ与指定人聊天。

```swift
-(void)didClickQQButton{
    //需要在info.plist中增加LSApplicationQueriesSchemes数组，然后添加item0，item0对应的值为mqqapi；增加item1，item1的值为mqq。
    NSString * QQNumber=@"";
    if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"mqq://"]]) {
        UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];

        NSURL * url=[NSURL URLWithString:[NSString stringWithFormat:@"mqq://im/chat?chat_type=wpa&uin=%@&version=1&src_type=web", QQNumber]];

        NSURLRequest *request = [NSURLRequest requestWithURL:url];

        webView.delegate = self;

        [webView loadRequest:request];

        [self.view addSubview:webView];

    }else{

        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"nil" message:@"对不起，您还没安装QQ" preferredStyle:UIAlertControllerStyleAlert];

        UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {
            return ;
        }];
        [alertController addAction:cancelAction];

        [self presentViewController:alertController animated:YES completion:nil];
    }
}
```
###71.一些控件没有`setBackgroundImage`方法的可以用这个设置背景图片

```swift
[self.view setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"1.png"]]];

```
###72.设置震动和声音

```swift
导入：AudioToolbox.framework框架 
在需要用到的地方导入 #import <AudioToolbox/AudioToolbox.h> 
AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);//震动 
AudioServicesPlaySystemSound(1000);//新邮件提示音
```
###73.删除所有子控件

```swift
[self.view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
```
###74.`NSString` 过滤特殊字符

```swift
// 定义一个特殊字符的集合
NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@"@／：；（）¥「」＂、[]{}#%-*+=_\\|~＜＞$€^•'@#$%^&*()_+'\""];
// 过滤字符串的特殊字符
NSString *newString = [trimString stringByTrimmingCharactersInSet:set];
```
###75.`app`提交审核上架关于`IDFA`广告标识符——`IDFA(identifier for advertising)`

* `app`提交审核最后一步：此`app`是否含有广告标识符`IDFA`？后面有两个选项：是、否？
 * 怎么选择或者看自己项目中是否采集了`IDFA`呢？可以在项目中`General`下拉到`framework`，看有没有一个`AdSupport.framework`的`framework`，有的话就选择是，没有就选择否。

###76.`iOS`项目里加载本地`HTML`
* 将前端给你打包的`html+css+js`文件夹托到`Xcode`项目里
* `@"index"`为你的`html`文件夹的入口文件名,`@"html"` 为你的文件格式,这个一般不变
* `Xcode`不能找到像`url（"../images/photo.png"）`这种路径，所以应该在`Xcode`中调整下`html`文件访问本页面图片和`css`样式文件的路径,将类似`"../images/photo.png"`的路径改为`"photo.png"`

```swift
UIWebView *web=[[UIWebView alloc]initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width, self.view.bounds.size.height-64)];

NSString *path = [[NSBundle mainBundle] pathForResource:@"index" ofType:@"html"];

NSString *htmlString = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];

NSString *basePath = [[NSBundle mainBundle] bundlePath];

NSURL *baseURL = [NSURL fileURLWithPath:basePath];

[web loadHTMLString:htmlString baseURL:baseURL];

[self.view addSubview:web];
```
###77.`layoutSubviews`调用的调用时机
* 当视图第一次显示的时候会被调用
* 当这个视图显示到屏幕上了,点击按钮
* 添加子视图也会调用这个方法
* 当本视图的大小发生改变的时候是会调用的
* 当子视图的`frame`发生改变的时候是会调用的,当然前提是`frame`的值设置前后发生了变化
* 当删除子视图的时候是会调用的
* 直接调用`setLayoutSubviews`。
* 滑动`UIScrollView`的时候。
* 旋转`Screen`会触发父`UIView`上的`layoutSubviews`事件
* `init`初始化不会触发`layoutSubviews`,但是是用`initWithFrame`进行初始化时，当`rect`的值不为`CGRectZero`时,也会触发

> * `layoutSubviews`方法：这个方法，默认没有做任何事情，需要子类进行重写
> * `setNeedsLayout`方法： 标记为需要重新布局，异步调用`layoutIfNeeded`刷新布局，不立即刷新，但`layoutSubviews`一定会被调用
> * `layoutIfNeeded`方法：如果有需要刷新的标记，立即调用`layoutSubviews`进行布局（如果没有标记，不会调用`layoutSubviews`）


###78.使 `tableViewCell`分割线的两头都接触边缘

```swift
//首先在viewDidLoad方法加入以下代码：
 if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) {
        [self.tableView setSeparatorInset:UIEdgeInsetsZero];    
	}   
 if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) {        
        [self.tableView setLayoutMargins:UIEdgeInsetsZero];
	}
//然后在重写willDisplayCell方法
- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell 
forRowAtIndexPath:(NSIndexPath *)indexPath{   
    if ([cell respondsToSelector:@selector(setSeparatorInset:)]) {       
             [cell setSeparatorInset:UIEdgeInsetsZero];    
    }    
    if ([cell respondsToSelector:@selector(setLayoutMargins:)]) {        
             [cell setLayoutMargins:UIEdgeInsetsZero];    
    }
}
```
###79.让`iOS`应用直接退出

```swift
- (void)exitApplication {
    AppDelegate *app = [UIApplication sharedApplication].delegate;
    UIWindow *window = app.window;
    [UIView animateWithDuration:1.0f animations:^{
        window.alpha = 0;
    } completion:^(BOOL finished) {
        exit(0);
    }];
}
```
###80.设置`Label`中不同文字的颜色

```swift
- (void)touchesEnded:(NSSet<UITouch> *)touches withEvent:(UIEvent *)event
{
    [self editStringColor:self.label.text editStr:@"好" color:[UIColor blueColor]];
}
 
- (void)editStringColor:(NSString *)string editStr:(NSString *)editStr color:(UIColor *)color {
    // string为整体字符串, editStr为需要修改的字符串
    NSRange range = [string rangeOfString:editStr];
    NSMutableAttributedString *attribute = [[NSMutableAttributedString alloc] initWithString:string];
    // 设置属性修改字体颜色UIColor与大小UIFont
    [attribute addAttributes:@{NSForegroundColorAttributeName:color} range:range];
    self.label.attributedText = attribute;
}
```
###81.播放声音

```swift
#import<AVFoundation>
 //  1.获取音效资源的路径
 NSString *path = [[NSBundle mainBundle]pathForResource:@"pour_milk" ofType:@"wav"];
 //  2.将路劲转化为url
 NSURL *tempUrl = [NSURL fileURLWithPath:path];
 //  3.用转化成的url创建一个播放器
 NSError *error = nil;
 AVAudioPlayer *play = [[AVAudioPlayer alloc]initWithContentsOfURL:tempUrl error:&error];
 self.player = play;
 //  4.播放
 [play play];
```
###82.调整`Label`行间距

```swift
-（void）test{
    NSMutableAttributedString *attributedString =    
   [[NSMutableAttributedString alloc] initWithString:self.contentLabel.text];
    NSMutableParagraphStyle *paragraphStyle =  [[NSMutableParagraphStyle alloc] init];  
   [paragraphStyle setLineSpacing:3];
    //调整行间距       
   [attributedString addAttribute:NSParagraphStyleAttributeName
                         value:paragraphStyle 
                         range:NSMakeRange(0, [self.contentLabel.text length])];
   self.contentLabel.attributedText = attributedString;
}

```
###83.`UIImageView`填充模式

```swift
@"UIViewContentModeScaleToFill",      // 拉伸自适应填满整个视图  
@"UIViewContentModeScaleAspectFit",   // 自适应比例大小显示  
@"UIViewContentModeScaleAspectFill",  // 原始大小显示  
@"UIViewContentModeRedraw",           // 尺寸改变时重绘  
@"UIViewContentModeCenter",           // 中间  
@"UIViewContentModeTop",              // 顶部  
@"UIViewContentModeBottom",           // 底部  
@"UIViewContentModeLeft",             // 中间贴左  
@"UIViewContentModeRight",            // 中间贴右  
@"UIViewContentModeTopLeft",          // 贴左上  
@"UIViewContentModeTopRight",         // 贴右上  
@"UIViewContentModeBottomLeft",       // 贴左下  
@"UIViewContentModeBottomRight",      // 贴右下
```
###84.设置状态栏文字的样式/颜色

```swift
[[UIApplication sharedApplication] setStatusBarHidden:NO];
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
```
###85.字符串除去空格需求，转变字母大小写

```swift
去除所有的空格
[str stringByReplacingOccurrencesOfString:@" " withString:@""]
去除首尾的空格
[str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
 
- (NSString *)uppercaseString; 全部字符转为大写字母
- (NSString *)lowercaseString 全部字符转为小写字母
```
###86.屏幕截图

```swift
// 1. 开启一个与图片相关的图形上下文
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size,NO,0.0);
 
    // 2. 获取当前图形上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
 
    // 3. 获取需要截取的view的layer
    [self.view.layer renderInContext:ctx];
 
    // 4. 从当前上下文中获取图片
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
 
    // 5. 关闭图形上下文
    UIGraphicsEndImageContext();
 
    // 6. 把图片保存到相册
    UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
```
###87.动态设置导航条`hidden`

```swift
//1.当我们的手离开屏幕时候隐藏
- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset
{ 
	if(velocity.y > 0) 
	{
		[self.navigationController setNavigationBarHidden:YES animated:YES];
	} else {
		[self.navigationController setNavigationBarHidden:NO animated:YES]; 
	}
}
velocity.y这个量，在上滑和下滑时，变化极小（小数），但是因为方向不同，有正负之分，这就很好处理了。

//2.在滑动过程中隐藏
//像safari
(1) 
self.navigationController.hidesBarsOnSwipe = YES;

(2)
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
 	CGFloat offsetY = scrollView.contentOffset.y + __tableView.contentInset.top;
 	CGFloat panTranslationY = [scrollView.panGestureRecognizer translationInView:self.tableView].y;
 	if (offsetY > 64) {
 		if (panTranslationY > 0) 
		{ 
			//下滑趋势，显示 
			[self.navigationController setNavigationBarHidden:NO animated:YES];
		} else { 
			//上滑趋势，隐藏 
			[self.navigationController setNavigationBarHidden:YES animated:YES]; 
		}
	} else {
		[self.navigationController setNavigationBarHidden:NO animated:YES]; 
	}
}
这里的offsetY > 64只是为了在视图滑过navigationBar的高度之后才开始处理，防止影响展示效果。panTranslationY是scrollView的pan手势的手指位置的y值，可能不是太好，因为panTranslationY这个值在较小幅度上下滑动时，可能都为正或都为负，这就使得这一方式不太灵敏.

```
###88.图片拉伸

```swift
UIImage* img=[UIImage imageNamed:@"2.png"];//原图
UIEdgeInsets edge=UIEdgeInsetsMake(0, 10, 0,10);
//UIImageResizingModeStretch：拉伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片
//UIImageResizingModeTile：平铺模式，通过重复显示UIEdgeInsets指定的矩形区域来填充图
img = [img resizableImageWithCapInsets:edge resizingMode:UIImageResizingModeStretch];
self.imageView.image=img;
```
###89.去掉导航栏/tabBar上的黑线

```swift
[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[UIImage new]];
// 再设置导航条背景颜色，需要关闭导航条透明效果才能显示出来。
self.navigationController.navigationBar.translucent = NO;

// tabbar
[self.tabBarController.tabBar setBackgroundImage:[UIImage new]];
[self.tabBarController.tabBar setShadowImage:[UIImage new]];
```
###90.`UIImage`与字符串互转

```swift
//图片转字符串  
-(NSString *)UIImageToBase64Str:(UIImage *) image  
{  
    NSData *data = UIImageJPEGRepresentation(image, 1.0f);  
    NSString *encodedImageStr = [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];  
    return encodedImageStr;  
}
//字符串转图片  
-(UIImage *)Base64StrToUIImage:(NSString *)_encodedImageStr  
{  
    NSData *_decodedImageData   = [[NSData alloc] initWithBase64Encoding:_encodedImageStr];  
    UIImage *_decodedImage      = [UIImage imageWithData:_decodedImageData];  
    return _decodedImage;  
}
```
###91. `NSDate`与`NSString`的相互转化

```swift
- (NSString *)dateToString:(NSDate *)date {
  // 初始化时间格式控制器
  NSDateFormatter *matter = [[NSDateFormatter alloc] init];
  // 设置设计格式
  [matter setDateFormat:@"yyyy-MM-dd hh:mm:ss zzz"];
  // 进行转换
  NSString *dateStr = [matter stringFromDate:date];
  return dateStr;
}
- (NSDate *)stringToDate:(NSString *)dateStr {
  // 初始化时间格式控制器
  NSDateFormatter *matter = [[NSDateFormatter alloc] init];
  // 设置设计格式
  [matter setDateFormat:@"yyyy-MM-dd hh:mm:ss zzz"];
  // 进行转换
  NSDate *date = [matter dateFromString:dateStr];
  return date;
}
```
###92.`UIWebView`退出时，使音频停止播放

```swift
- (void)viewDidDisappear:(BOOL)animated{    
	DLog(@"媒体打开窗口被隐藏");    
	[webViewer loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"about:blank"]]];
}
```
###93.头部视图放大

```swift
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    /**
     *  这里的偏移量是纵向从contentInset算起 则一开始偏移就是0 向下为负 上为正 下拉
     */
    // 获取到tableView偏移量
    CGFloat Offset_y = scrollView.contentOffset.y;
    // 下拉 纵向偏移量变小 变成负的
    if ( Offset_y < 0) {
        // 拉伸后图片的高度，200是头部视图的高度
        CGFloat totalOffset = 200 - Offset_y;
        // 图片放大比例，200是头部视图的高度
        CGFloat scale = totalOffset / 200;
        CGFloat width = kScreenWidth;
        // 拉伸后图片位置
        _vip.vipBackground.frame = CGRectMake(-(width * scale - width) / 2, Offset_y, width * scale, totalOffset);
    }
}
```
###94.递归缩放包含矢量内容的视图，防止模糊和锯齿
* 当对含有矢量内容的视图进行缩放时会有模糊和锯齿出现，这时递归需要改变 `UIView` 的 `contentScaleFactor` 和 `CALayer` 的 `contentsScale` 属性：

```swift
- (void)updateForZoomScale:(CGFloat)zoomScale {
    CGFloat screenAndZoomScale = zoomScale * [UIScreen mainScreen].scale;
    // Walk the layer and view hierarchies separately. We need to reach all tiled layers.
    [self applyScale:screenAndZoomScale toView:self];
    [self applyScale:screenAndZoomScale toLayer:self.layer];
}
- (void)applyScale:(CGFloat)scale toView:(UIView *)view {
    view.contentScaleFactor = scale;
    for (UIView *subview in view.subviews) {
        [self applyScale:scale toView:subview];
    }
}
- (void)applyScale:(CGFloat)scale toLayer:(CALayer *)layer {
    layer.contentsScale = scale;
    for (CALayer *sublayer in layer.sublayers) {
        [self applyScale:scale toLayer:sublayer];
    }
}
```
###95.判断某个点是否在『视图区域』内,避免`Rotation`形变手势带来的`frame`差错
* 是因为当视图旋转（90°倍数除外）之后 `frame` 并不等于『视图区域』.
![](/Users/liuzhigao/Desktop/自定义转场动画/0.jpg)

```swift
/**
*  判断某个点是否在视图区域内，针对 transform 做了转换计算，并提供 UIEdgeInsets 缩放区域的参数
*
*  @param point  要判断的点坐标
*  @param view   传入的视图，一定要与本视图处于同一视图树中
*  @param insets UIEdgeInsets参数可以调整判断的边界
*
*  @return BOOL类型，返回点坐标是否位于视图内
*/
- (BOOL)checkPoint:(CGPoint) point inView:(UIView *)view withInsets:(UIEdgeInsets)insets
{
    // 将点坐标转化为视图内坐标系的点，消除 transform 带来的影响
    CGPoint convertedPoint = [self convertPoint:point toView:view];
    CGAffineTransform viewTransform = view.transform;
    // 计算视图缩放比例
    CGFloat scale = sqrt(viewTransform.a * viewTransform.a + viewTransform.c * viewTransform.c);
    // 将 UIEdgeInsets 除以缩放比例，以便得到真实的『周围区域』
    UIEdgeInsets scaledInsets = (UIEdgeInsets){insets.top/scale,insets.left/scale,insets.bottom/scale,insets.right/scale};
    CGRect resultRect = UIEdgeInsetsInsetRect(view.bounds, scaledInsets);
    // 判断给定坐标点是否在区域内
    if (CGRectContainsPoint(resultRect, convertedPoint)) {
        return YES;
    }
    return NO;
}
```
###96.设置导航栏背景颜色

```swift
// 方法一
UINavigationBar.appearance().barTintColor = UIColor(hexString: "1766AE")
// 方法二
navigationController?.navigationBar.isTranslucent = false
再设置backgroundColor的背景颜色


```
###97.设置状态栏颜色

```swift
- (void)setStatusBarBackgroundColor:(UIColor *)color {
    UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@"statusBarWindow"] valueForKey:@"statusBar"];
    if ([statusBar respondsToSelector:@selector(setBackgroundColor:)]) {
        statusBar.backgroundColor = color;
    }
}
```
###98.用颜色生成一张图片

```swift
+ (UIImage *)imageWithColor:(UIColor *)color
{
    // 描述矩形
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    // 开启位图上下文
    UIGraphicsBeginImageContext(rect.size);
    // 获取位图上下文
    CGContextRef context = UIGraphicsGetCurrentContext();
    // 使用color演示填充上下文
    CGContextSetFillColorWithColor(context, [color CGColor]);
    // 渲染上下文
    CGContextFillRect(context, rect);
    // 从上下文中获取图片
    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();
    // 结束上下文
    UIGraphicsEndImageContext();
    return theImage;
}
```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```
###18.判断view是不是指定视图的子视图

```swift

```