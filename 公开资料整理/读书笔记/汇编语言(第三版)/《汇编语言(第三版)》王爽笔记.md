#《汇编语言(第三版)》笔记
##第一章：基础知识
* 汇编语言是直接在硬件之上工作的编程语言。
* 《微机原理与接口》：关于 PC 机及 CPU 物理结构和编程结构全面研究
* 《组成原理》：计算机一班的结构、功能、性能的研究

>####1.机器语言
>* 机器指令的集合。
>* 机器指令是一台机器可以正确执行的命令，是一列二进制数字，计算机再将其转为高低电平。
>* 早期计算机概念：可以执行机器指令，进行运算的机器。
>* 如今以上功能由 PC 机内的 CPU(中央处理单元) 完成。CPU 是一种微型处理器。
>* 近代计算机概念：由 CPU 和其他受 CPU 直接或间接控制的芯片、器件、设备组成计算机系统
>* 每一种微处理器都有自己的机器指令集
>
>####2.汇编语言的产生
>* 汇编语言的主体是汇编指令。和机器指令的区别在于指令的表示方法上。
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170514_1.png)
>* 寄存器：CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。`AX`和`BX`都是寄存器的代号。
>* 编译器：提供将汇编指令转换成机器指令的程序
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170528_1.png)
>
>####3.汇编语言的组成
>* 以下三类指令组成
>  * 汇编指令：机器码的助记符，有对应的机器码。
>  * 伪指令：没有对应的机器码，由编译器执行，计算机并不执行。
>  * 其他符号：由编译器识别，没有对映的机器码。
>
>推荐详细了解底层结构的书籍：[编码的奥秘](http://baike.baidu.com/link?url=N-YhQjBbdKfWMfAaE4vo9j7ExusgdPaw7BcxZzMEjNnEqtTW_MqoHFGOreriT98MvMyqnZiilt-YkBJ7XvmSuvvro_1LibInKsRzeeLBu0uZNAT1YKbjfcGtH3iKHkQA21if1WL-1ppaYHYI2WFSpK)
>
>####4.存储器
>* CPU 是计算机的核心部件，控制整个计算机的运作并运算。
>* 让 CPU 工作，需要向它提供指令和数据，指令和数据存储在储存器中(内存)
>* 磁盘不同于内存，磁盘上的数据或程序不读到内存中，就无法被CPU使用。
>
>####5.指令和数据
>* 都是二进制信息，只是在应用上的概念，程序员为同样的信息赋予了不同的意义。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170526_9.png)
>
>####6.存储单元
>* 存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号。
>* <mark>一个存储单元只能存储一`Byte`(字节-->8位)的数据</mark>
>* 存储器不一定是内存，如：显存。
>
>####7.CPU对存储器的读写
>* CPU要从内存中读数据，要制定存储单元的地址，就是哪个存储单元中的数据。
>* 对存储器以外的器件，CPU要进行数据的读写，必须进行以下交互：
>  * 存储单元的地址(地址信息)
>  * 器件选择，读或写的命令(控制信息)
>  * 读或写的数据(数据信息)
>* 计算机通过电信号处理、传递信息，电信号通过导线传递。专门有连接 CPU 和其他芯片的导线，通常称为总线(物理角度：一根根导线的集合)。根据传递的信息的不同，又分为：地址总线、控制总线和数据总线。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/汇编1.gif)
>
>* 命令计算机进行数据的读写。
>  * 向它输入能够驱动它进行工作的电平信息(机器码，高／低电平)。
> ![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170526_11.png)
>
>####8.地址总线
>* 指定存储器单元。
>* 一个 CPU 有 N 根地址线，则这个 CPU 的地址总线的宽度为 N，最多可以表示 2 的 N 次方个不同的内存单元。
>* 达到真正的64 位的操作速度：CPU(64)，系统(64)，软件(64).
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170528_3.png)
>
>####9.数据总线
>* CPU 与内存或其他器件之间的数据传送
>* 数据总线的宽度决定了 CPU 和外界数据的传送速度。
>* <mark>一根数据总线一次可传送一个一位二进制数据(即 1 bit，1/8的字节(Byte))</mark>
>
>####10.控制总线
>* CPU对外界器件的控制
>* 有多少根控制总线，意味着 CPU 提供了外部器件的多少种控制，所以控制总线的宽度决定了 CPU 对外部器件的控制能力。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170527_4.png)
>
>* 答案在下一期，[讨论区在这里](http://www.asmedu.net/bbs/forum.jsp)
>
>####11.内存地址空间(概念)
>* 一个 CPU 的地址总线宽度为 10 ，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。
>
>####12.主板
>* 每台计算机中都有一个主板，包含核心器件和主要器件，通过总线相连。
>* CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般有内存条和各类接口卡。
>
>####13.接口卡
>* 计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。
>* 直接控制外部设备的是扩展卡槽上的接口卡，扩展卡槽通过总线和 CPU 相连，对外部设备实现间接控制。
>
>####14.各类储存器芯片
>* 从读写属性可分两类
>  * **随机存储器(`RAM`)：**可读可写，但必须带电存储，关机后内容丢失
>  * **只读存储器(`ROM`)：**只读取不能写入，关机后内容不丢失。
>* 从功能连接上又可分类
>  * **随机存储器：**存放 CPU 绝大部分程序和数据，一般由装在主板上的 RAM 和插在扩展插槽上的 RAM 组成。
>  * **装有 BIOS 的 ROM：**BIOS 是由主板和各类接口卡(如显卡、网卡)厂商提供的软件系统，对该硬件设备实现最基本的输入输出。在主板和某些接口卡上插有对应设备的相应 BIOS 的 ROM。如：主板的 ROM中存储着主板的 BIOS，显卡的 ROM中存储着显卡的 BIOS。
>  * **接口卡上的RAM：**某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM，如显卡。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170528_4.png)
>
>
>####15.内存地址空间
>* 上述存储器在一下两点上相同：
>  * 都和 CPU 的总线相连。
>  * CPU 对它们进行读写命令时都是通过控制线发出。
>* CPU 将各类存储器看作一个逻辑存储器(内存地址空间)：
>  * 所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器。
>  * 每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。
>  * CPU 在这段地址空间中读写数据，实际上就是在相对应地物理存储器中读写数据。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170528_5.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170614_1.png)
>

```swift
// 监测点 1.1 答案分析(通过网络翻阅，尽可能详细)
1.答案：13
  解析：8KB = 8*1024 Byte = 2的13次方 Byte  
	    因为每个内存单元是1 Byte，所以地址总线就是13根。
2.答案：1KB 的存储器有 1024 个存储单元。存储单元的编号从 0 到 1023。3.答案：1KB 的存储器可以存储 1024*8 个 bit，1024 个 Byte。4.答案：1GB、1MB、1KB 分别是 2^30、2^20、2^10 Byte。(n^m 的意思是 n 的 m 次幂) 
5.答案：8080、8088、80286、80386 的地址总线宽度分别是 16 根、20 根、24 根、32 根，则它们的寻址能力分别为:64(KB)、1(MB)、16(MB)、4(GB)。 
6.答案：8080、8088、8086、80286、80386 的数据总线宽度分别为 8 根、8 根、16 根、 16 根、32 根。则它们一次可以传送的数据为:1(B)、1(B)、2(B)、2(B)、4(B)。 
7.答案：从内存中读取 1024 字节的数据，8086 至少要读 512 次、80386 至少要读 256 次。8.答案：在存储器中，数据和程序以二进制形式存放。
```

##第二章：寄存器
* 一个 CPU 基本由：运算器、控制器、寄存器等器件构成，靠内部总线相连。
  * 运算器进行信息处理
  * 寄存器进行信息存储
  * 控制器控制各种器件进行工作
  * 内部总线连接各种器件，在数据传递
* 对于程序员来讲，主要部件是寄存器，寄存器是程序员可以用指令读写的部件。
* **(了解)**8086CPU(一个古老的CPU)有 14 的寄存器：AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW。

>####1.通用寄存器
>* 8086CPU的所有寄存器都是 16 位的，可以存放两个字节（一个字节 8 位）。
>* AX，BX，CX，DX这 4 个存储器通常放一般性的数据，被称为通用寄存器。
> ![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170529_1.png)
> 
>* 一个 16 位寄存器可以存储一个 16 位的数据，最大值为 `2的16次方 - 1`
>* 8086CPU的上一代 CPU 中的寄存器都是 8 位，为了保证兼容，AX，BX，CX，DX都可以分为两个独立使用的 8 位寄存器。
>  * AX 可分为 AH(`height`) 和 AL(`low`)。
>  * BX 可分为 BH(`height`) 和 BL(`low`)。
>  * CX 可分为 CH(`height`) 和 CL(`low`)。
>  * DX 可分为 DH(`height`) 和 DL(`low`)。
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170529_3.png)
>
>####2.字在寄存器中的存储
>* 出于兼容新考虑，8086CPU可以一次性处理两种尺寸的数据
>  * 字节(`byte`)：一个字节由 8 个 `bit` 组成，存在 8 位寄存器中。
>  * 字(`word`)：一个字由两个字节组成，分别称为高位字节、低位字节。
> ![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170529_2.png)
> 
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170530_10.png)
>
>####3.几条汇编指令
>* 一条汇编指令或一个寄存器的名称不区分大小写。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170530_4.png)
>
>* **练习：**请计算一下下面表格的结论.
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170530_7.png)
>
>  * (**在第三行卡住了，才知每一行的结论都是相关连的。😅**)
>  * (**其次：**如`mov ax, 001AH`,`001AH`不要想当然就是`bx`。)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170530_8.png)
>
>* **练习：**请计算一下下面表格的结论.
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170530_9.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170530_13.png)
>
>* 系统自带的计算器都有进制转换的功能，请结合计算。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170601_3.png)
>
>* 答案在下一期
>
>####4.物理地址
>* 所有内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在空间中都有唯一的地址(物理地址)。
>* 在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成物理地址。
>
>####5.16位结构的CPU
>* `8086CPU`是 16 位机(`16 位结构的CPU`)
>  * 运算器一次最多可以处理16位数据
>  * 寄存器的最大宽度为 16 位
>  * 寄存器和存储器之间的通路为 16 位
>
>####6.8086CPU给出的物理地址的方法
>* 8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1MB （1MB=1024x1024=2的20次方）寻址能力
>* 8086CPU 又是 16 位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。
>* 从内部结构看：简单的发出只能送出 16 位的地址，表现出 64KB 的选址能力。
>* 8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_7.png)
>
>* 地址加法器采用**物理地址=段地址x16+偏移地址**的方法用段地址和偏移地址合成物理地址。
>* 例如，8086CPU 要访问地址为123C8H的内存单元，过程如下：
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_8.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_10.png)
>
>>* 个人理解
>>
>>* 结合上面两张图，再结合计算，我起初还不明白，`1230x16=12300?``WHY？`
>>* 通过计算和对第二张图的理解
>>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_11.png)
>>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_12.png)
>>* 图中二进制向左移了四位
>>* 集合上图中结论：一个 X 进制的数据左移 1 位，相当于乘以 X。
>>* 我一个一个的乘以2，发现确实等于 12300
>>* 突然知道，16 是十进制的，转换成 16 进制是 10 😅。
>>* 结论：16 要转换成相同进制再计算。
>>* 结论：十六进制的段地址 x16，结果就是加一个 0.
>
>####7.“物理地址=段地址x16+偏移地址”的本质含义
>* **本质含义：**CPU 在访问内存时，用一个基础地址（段地址x16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。
>* 段地址x16可以看作是基础地址。
>
>####8.段的概念
>* 内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用 "物理地址=基础地址(段地址x16)+偏移地址" 的方式给出内存单元的物理地址，我们可以用分段的方式来管理内存。
>* 偏移地址为 16 位，16 位地址的寻址能力为 64K，所以一个段的长度最大为 64K 。
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_14.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_16.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_17.png)
>* 答案见下回
>
>####9.段寄存器
>* 段地址在 8086CPU 的段寄存器中存放。
>* 8086CPU 有 4 个段寄存器：CS(代码段寄存器)、DS(数据段寄存器)、SS(堆栈段寄存器)、ES(附加段寄存器，前面几个放不下，就放在这里)
>* 当 8086CPU 要访问内存时由这 4 个段寄存器提供内存单元的段地址。
>
>####10.CS和IP
>* CS 和 IP 是 8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。
>* CS 为代码段寄存器，IP 为指令指针寄存器。
>* 8086CPU 中任意时刻，CPU 将 CS:IP 指向的内容当作指令执行
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170615_29.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/未命名xx.gif)
>
>* 读取一条指令后，IP 中的值自动增加，以使 CPU 可以读取下一条指令。当前读入的指令 B82301 
>* 1. 从 `CS:IP` 指向的内存单元读取指令，读取的指令进入指令缓冲器；
>* 2. IP = IP + 所读指令的长度，从而指向下一条指令；
>* 3. 执行指令。转到步骤(1)，重复这个过程。
>* CS 和 IP 的内容提供了 CPU 要执行指令的地址。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170617_2.png)
>
>####11.修改 CS、IP 的指令
>* 在 CPU 中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对 CPU 的控制。CPU 从何处执行指令是由 CS、IP 中的内容决定的，程序员可以通过改变 CS、IP 中的内容来控制执行目标指令。
>* `mov：`传送指令，不能用于设置 CS、IP 的值。
>* 转移指令：能够改变 CS、IP 的内容的指令
>* `jmp：`一个最简单的可以修改 CS、IP 的指令
>
>>`jmp 2AE3:3`,执行后：`CS=2AE3H`，`IP=0003H`，`CPU` 将从 `2AE33H` 处读取指令。
>>
>>
>>* "`jmp 段地址:偏移地址`" 指令的功能为：用指令中给出的段地址修改 CS，偏移地址修改 IP。
>>* "`jmp 某一合法寄存器`" 指令的功能为：用寄存器中的值修改 IP。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170617_13.png)
>
>####12.代码段
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170617_14.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170617_17.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170617_19.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_4.png)
>
>####实验 1 查看 CPU 和内存，用机器指令和汇编编程
>* 步骤较多，就不放上来了
>* 不过，强烈建议去实践一下
>

##debug使用记录
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_2.png)
>
>* **r** 命令
>  * `r`：查看 CPU 寄存器的状态
>  * `r ax`：修改一个寄存器中的值
> 
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_6.png)
>
>* **d**命令
>  * `d`：查看`Debug`预设的地址处内容
>  * `d 段地址:偏移地址`：查看从制定内存单元开始的 128 个内存单元的内容
>  * 在上一个指令之后再使用`d`指令，将列出后续 128 个内存单元的内容
>  * `d 段地址:起始偏移地址 结尾偏移地址`：查看制定范围的内容，亲测`初始偏移地址`是两位数会出错？
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_11.png)
>
>* **e**命令
>  * `e 起始地址 数据 数据 数据 ......`：起始地址(段地址:偏移地址)；改写内存中的内容。
>  * `e 段地址:偏移地址`：然后光标停在`.`后面表示输入需要修改的内容；这里是按空格键结束该单元的修改；直接按空格键，表示不修改，直接结束该单元的修改；接着显示下一个内存单元的原始地址，并以同样的方式进行修改；按回车结束该操作。
>  * 可以向内存中写入字符／字符串
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_19.png)
>
>* **u** 命令
>  * `u 初始地址`：查看内存中机器码对应的汇编指令
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_20.png)
>
>* **t** 命令
>  * `t`：执行`CS:IP`指向的指令，指令执行后，`Debug`会输出CPU中寄存器的状态。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_24.png)
>
>* **a** 命令
>  * `a 初始地址`：以汇编指令的形式在内存中写入机器码，直接回车，结束操作
>  * `a`：从一个预设地址开始输入指令，直接回车，结束操作
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_25.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_26.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_27.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170623_31.png)

```
假设CPU寻址上限为Max，地址总线的宽度为N，那么：Max=2^N，即cpu寻址范围为：0到2^N。 
例：地址总线为16位，侧Max=2^16=65535=0xFFFFh，     
即CPU得寻址范围为：0x0000h到0xFFFFh.
```

##第三章：寄存器(内存访问)
>####1.内存中字的储存
>* CPU 中，用 16 位寄存器来储存一个字。高 8 位存放高位字节，低 8 位存放低位字节。
>* 一个内存单元是一个字节单元。
>* **子单元：**存放一个字型数据(16 位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170708_2.png)
>
>####2.DS和[address]
>* 8086CPU 中有一个 DS 寄存器，通常用来存放要访问数据的段地址。
>
>```swift
>// 将 10000H(1000:0)中的数据读到 al 中
>mov bx, 1000H
>mov ds,bx
>mov al,[0]
>```
>* `mov al,[0]`指令的含义：
>	* `mov`指令：1. 将数据直接送入寄存器；2. 将一个寄存器中的内容送入另一个寄存器。
>	* `mov 寄存器名 内存单元地址`
>	* `[...]`表示一个内存单元；`0`表示偏移地址；段地址自动到`DS`中取。
>* 8086CPU不支持将数据直接送入段寄存器中，DS 就是段寄存器。这属于 8086CPU 硬件设计的问题。可以先将数据存到一般寄存器，再存入段寄存器。
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170715_1.png)
>
>####3.字的传送
>* 8086CPU是 16 位结构，可以一次性传送 16 位数据，也就是一个字。
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170715_2.png)
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170715_4.png)
>
>####4.mov、add、sub指令
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170715_5.png)
>
>* 推倒出的结果
>	* `mov 寄存器，段寄存器`
>	![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170718_1.png)
>	* `mov 内存单元，段寄存器`
>	![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170718_2.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170715_6.png)
>
>* 其他操作自行验证。
>
>####5.数据段
>* 将一组长度为 N(N<=64KB)、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。
>	* 比如用`123B0H~123B9H`这段内存空间来存放数据，那就可以认为这段内存是一个数据段，段地址为`123BH`，长度为 `10` 个字节。
>
>>* 如何访问数据段中的数据？
>>	* 可以在具体操作时，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。
>>
>>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_1.png)	
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_2.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_9.png)
>
>####测试点 3.1 (略)
>
>####6.栈
>* 栈是一种具有特殊的访问方式的存储空间。
>	* 特殊性在于，最后进入空间的数据，最先出去。
>
>####7.CPU 提供的栈机制
>* 现今的 CPU 中都有栈的设计，8086 也不例外。
>	* 8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH(入栈) 和 POP(出栈)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_10.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_13.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_3.png)
>
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_8.png)
>
>####8.栈顶超界的问题
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_11.png)
>
>* 栈顶超界是危险的，因为在栈空间之外的空间里很可能存放了具有其他用途的数据，代码等，但是由于我们在入栈出栈时的不小心，而将这些数据，代码意外的改写，将会引发一连串的错误。
>* 8086CPU 不保证对栈的操作不会超界。
>
>####9.push、pop指令
>![](/Users/liuzhigao/Desktop/自定义转场动画/Snip20170812_15.png)